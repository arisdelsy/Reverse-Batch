program reverse;

#include reverse.iri 

--Screens
  g_ciMain       : constant integer := 14;
  g_ciCust       : constant integer := 2;
  g_ciShip       : constant integer := 3;
  g_ciProduct    : constant integer := 4;
  g_ciYN         : constant integer := 5;
  g_ciSetup      : constant integer := 10;
  g_ciBatch      : constant integer := 1;
  g_ciaddcust    : constant integer := 8;
  g_ciScales     : constant integer := 9;
  g_ciAddOns     : constant integer := 13;
  g_ciBatchReady : constant integer := 12;
  g_ciLoad       : constant integer := 15;
  --Testing screen
  --g_ciTest    : constant integer := 99;

  -- Global/Types variables definitions 
  g_sTmpPassword : string;  
  g_rCountby : real;    
  --g_ibUpdate : boolean;
  g_iDecimal1 : integer;  
  g_uUnits : Units; 
  g_sysResult : SysCode;
  g_sysResult1 : SysCode;
  g_sysResult2 : SysCode;
  g_sysResult3 : SysCode;
  g_sysResult4 : SysCode;  
  g_iWidget : integer; -- this is for widget alias 
  g_iWidgetNum : integer; -- this is for columns
  g_iSelect   : integer;
  g_ciMaxPerScreen :integer;
  g_iPage : integer;
  r1current_select : integer;   
  r2current_select : integer; 
  g_iProductRow    : integer; -- mimics what is being done with g_iWidgetNum
  --Variables for storing inital weight of scales as well as target weights
  g_rInitial1 : real;
  g_rInitial2 : real;
  -- Variables for storing the targets from the database
  g_rtarget1  : real;
  g_rtarget2  : real;
  --Variables for storing the active scale weights to run the batch process
  g_rActive1 : real;
  g_rActive2 : real;
  -- Final weight values used to calculate how much material was batched onto the ticket
  g_rEnd1 : real;
  g_rEnd2 : real;
  --Actual ammount of material batched are in these variables
  g_rcembatch : real;
  g_rsandbatch : real;

  --------------- Accumulator values ----------------
  g_rCemAccum : stored real := 0;
  g_rSandAccum : stored real := 0;
  g_iBatchAcc : stored integer := 0;
  g_iTicketNum  : stored integer := 0;
  ---------------------------------------------------

  -- Printer port
  g_ciPrinter : constant integer := 1;
  
  --Accumulators
  g_sYards : stored integer := 0;
  g_sAgg   : stored integer := 0;
  g_sCem   : stored integer := 0;

  --Entry Modes are made to prevent deadlock 
  -- If you dont have them the program is vulnerable and could lock up
  NoMode              : constant integer := 0;
  CustomerSelectMode  : constant integer := 1000;
  RecipeSelectMode    : constant integer := 1001;
  SetupMenuMode       : constant integer := 1002;
  BatchMode           : constant integer := 1003;
  PrintMode           : constant integer := 1004;
  CustomerProcessMode : constant integer := 1006;
  ProductSelectMode   : constant integer := 1007;
  BatchCompleteMode   : constant integer := 1008;
  AddOnsMode          : constant integer := 1015;
  ShippingMode        : constant integer := 1022;
  YNClearOneMode      : constant integer := 1023;
  BatchReadyMode      : constant integer := 1024;
  YNShippingAddress   : constant integer := 1030;
  LoadMode            : constant integer := 1031;


-- Entry Modes for customer entry
  EnterPhoneMode          : constant integer := 1009;
  EnterNameMode           : constant integer := 1010;
  EnterStreetMode         : constant integer := 1011;
  EnterTownMode           : constant integer := 1012;
  EnterStateMode          : constant integer := 1013;
  EnterZipCodeMode        : constant integer := 1014;

  --EntryModes for shipping
  EnterOnsiteTelMode         : constant integer := 1016;
  EnterShipCustomerMode      : constant integer := 1017;
  EnterShipStreetMode        : constant integer := 1018;
  EnterShipTownMode          : constant integer := 1019;
  EnterShipStateMode         : constant integer := 1020;
  EnterShipZipCodeMode       : constant integer := 1021;

  -- EntryModes for 
  EnterPurchaseOrderMode     : constant integer := 1026;
  EnterPasswordMode          : constant integer := 1027;
  EnterNewPasswordMode       : constant integer := 1028;
 
 -- Number of Max record
  g_ciMaxRecords            : constant integer := 1000;
	g_ciMaxProducts						: constant integer := 24;	

  g_ciMaxPerSelectScreen    : constant integer := 8;

  Blank : constant string := "";

  -- Entry Mode variable to have the current entry mode
  EntryMode : integer;

  ------------- Used only for prompts ------------------
  g_Entrymode : integer; 
  ------------------------------------------------------

  lastReset : stored string := Blank; --Last reset date variable to display

  -- Backdoor password and user password
  backdoor_pass : constant string := "asc1058";
  sPassword : stored string;

  --String for barcode
  bar_string : string;

  --Temp variables for entry for customer info
  t_phonenum  : string;
  t_customer  : string;
  t_street    : string;
  t_town      : string;
  t_state     : string;
  t_zip       : string;

  -- Temp variables to store the shipping information to be printed to the ticket
  ts_onsite   : string;
  ts_customer : string;
  ts_street   : string;
  ts_town     : string;
  ts_state    : string;
  ts_zip      : string;
  t_purchase  : string;

  --Temp variables for product information
  t_psi       : integer;
  t_qtyconc   : real;
  t_sand      : real;
  t_cement    : real;
  t_wat_gal   : real;
  t_calcium   : integer;
  t_air_ent   : real;
  t_antihydr  : real;
  t_retard    : real;

  type boolean is (False,True); -- Boolean type declaration

-- Booleans to show that rows 1/2 are selected in the product selection screen (SEE THE SelectProduct PROCEDURE)
  r1_select : boolean := False;
  r2_select : boolean := False;

-------------------------------------------------------
  locked    : boolean := True; -- Boolean to show if the setup screen is locked or unlocked to prompt for the password
-------------------------------------------------------

-- Boolean values for selecting the add ons to be displayed onto the ticket for the batch
  bCalcium : boolean;
  bAnti_hydro : boolean;
  bAir_ent : boolean;
  bRetarder : boolean;

  type DisplayRecord is -- Array used to hold and display customer billing information for the selection screen
    record 
      sPhoneNum : string; 
      sName     : string;
      sStreet   : string;
      sTown     : string;
      sState    : string;
      sZip      : string;
    end record;     

  type ProductRecord is -- Array used to store the product information from the database
    record
      sPSI     : integer;
      sQTY_CONC: real;
      sSAND_MIX: real;
      sCEMENT  : real;
      sWAT_GALL: real;
      sCALCIUM : integer;
      sAIR_ENT : real;
      sANTIHYDR: real;
      sRETARDER: real;
    end record;    

-- this means we are creating a new type called DisplayArrays is an array which holds g_ciMaxRecords
-- amount of information which is a part of the DisplayRecord type (declared above)
  type DisplayArrays is array [g_ciMaxRecords] of DisplayRecord; 
  g_arDisplay : DisplayArrays;
  
  type ProductArrays is array [g_ciMaxProducts] of ProductRecord;
	g_arProduct : ProductArrays; --to make a selection from the product database

  CustomersDB : CustomerDatabase;
  ProductDB   : ProductDatabase;
  TransDB     : TransDatabase;
  
  procedure SetupStartTimer(iTimer : integer; iDuration : integer; itmMode : TimerMode); -- Setup a Timer and Start                                
  begin
  
    SetTimer(iTimer, iDuration);
    SetTimerMode(iTimer, itmMode);
    StartTimer(iTimer);
    
  end; 

  procedure WaitSS;
  begin

    SetupStartTimer(25, 10, TimerContinuous);
  
  end;   

  function CalcDecimal(rCountBy : real) : integer;  -- Calculates the amount of decimal positions  
    iDecimal : integer := 0;    
  begin   
         
    while rCountBy < 1.0
    loop    
      iDecimal := iDecimal + 1;
      rCountBy := rCountBy * 10.0;  
     end loop;

     return iDecimal; 
     
  end;

  procedure Delete25Percent;  
    i : integer;  
    dbCustSave : CustomerDatabase;   
  begin
    
    dbCustSave := CustomersDB; 
    CustomersDB.Sort(Customer_Name);
    CustomersDB.GetFirst;
    CustomersDB.Delete;
    
    for i := 1 to g_ciMaxRecords * 0.25
    loop
      CustomersDB.GetNext;
      CustomersDB.Delete; 
      DisplayStatus("Auto Deleting Customer Database");      
    end loop;       
    
    --CustomersDB.Name := SystemTime;
    CustomersDB := dbCustSave;   
    g_sysResult1 := CustomersDB.Add;
    
    if g_sysResult1 <> SysOk then
      DisplayStatus("Error: Customer Database"); 
    else
      DisplayStatus(Blank);
    end if;

  end;      

  procedure PromptForEntry(sPrompt : string;  iMode : integer; sDefault : string; iPrompt : integer);  -- Prompts operator for entry
  begin
    
    DisableHandler(NumericKeyPressed);
    DisableHandler(EnterKeyPressed);
    DisableHandler(NavUpKeyPressed);
    DisableHandler(NavDownKeyPressed);   
     
		SetEntry(sDefault);
    if iPrompt = 1 then   
      PromptUser(sPrompt);
    elsif iPrompt = 2 then
      PromptNumeric(sPrompt);
    elsif iPrompt = 3 then
      PromptPassword(sPrompt);
    else
      PromptUser(sPrompt);  
    end if;
    g_EntryMode := iMode;
    
  end;  

  procedure ProcessPromptCancel;   -- Performs Cancel operation when cancelling a prompt
    begin 
    
      ClosePrompt;  

      if g_Entrymode = EnterPhoneMode then 
        EntryMode := CustomerProcessMode;
        t_phonenum := Blank;
        SetLabelText(lbl224, Blank);
        SelectScreen(g_ciaddcust);
      elsif g_Entrymode = EnterNameMode then 
        EntryMode := CustomerProcessMode;
        t_customer := Blank;
        SetLabelText(lbl225, Blank);
        SelectScreen(g_ciaddcust);
      elsif g_Entrymode = EnterStreetMode then 
        EntryMode := CustomerProcessMode;
        t_street := Blank;
        SetLabelText(lbl226, Blank);
        SelectScreen(g_ciaddcust);
      elsif g_Entrymode = EnterTownMode then 
        EntryMode := CustomerProcessMode;
        t_town := Blank;
        SetLabelText(lbl227, Blank);
        SelectScreen(g_ciaddcust);
      elsif g_Entrymode = EnterStateMode then 
        EntryMode := CustomerProcessMode;
        t_state := Blank;
        SetLabelText(lbl228, Blank);
        SelectScreen(g_ciaddcust);
      elsif g_Entrymode = EnterZipCodeMode then 
        EntryMode := CustomerProcessMode;
        t_zip := Blank;
        SetLabelText(lbl229, Blank);
        SelectScreen(g_ciaddcust);
      elsif g_Entrymode = EnterOnsiteTelMode then 
        EntryMode := ShippingMode;
        ts_onsite := Blank;
        SetLabelText(lbl328, Blank);
        SelectScreen(g_ciShip);
      elsif g_Entrymode = EnterShipCustomerMode then 
        EntryMode := ShippingMode;
        ts_customer := Blank;
        SetLabelText(lbl335, Blank);
        SelectScreen(g_ciShip);
      elsif g_Entrymode = EnterShipStreetMode then 
        EntryMode := ShippingMode;
        ts_street := Blank;
        SetLabelText(lbl330, Blank);
        SelectScreen(g_ciShip);
      elsif g_Entrymode = EnterShipTownMode then 
        EntryMode := ShippingMode;
        ts_town := Blank;
        SetLabelText(lbl331, Blank);
        SelectScreen(g_ciShip);
      elsif g_Entrymode = EnterShipStateMode then 
        EntryMode := ShippingMode;
        ts_state := Blank;
        SetLabelText(lbl332, Blank);
        SelectScreen(g_ciShip);
      elsif g_Entrymode = EnterShipZipCodeMode then 
        EntryMode := ShippingMode;
        ts_zip := Blank;
        SetLabelText(lbl333, Blank);
        SelectScreen(g_ciShip);
      elsif g_Entrymode = EnterPurchaseOrderMode then 
        EntryMode := ShippingMode;
        t_purchase := Blank;
        SelectScreen(g_ciShip);
      elsif g_EntryMode = EnterPasswordMode then
        EntryMode := NoMode;
        g_sTmpPassword := Blank;
        SelectScreen(g_ciMain);
      elsif g_EntryMode = EnterNewPasswordMode then
        EntryMode := NoMode;
        g_sTmpPassword := Blank;
        SelectScreen(g_ciMain);
      else   
        DisplayStatus(Blank); 
        EntryMode := NoMode;  
      end if;
      
    end; 

  procedure ClearDisplayListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxRecords 
    loop
      if g_arDisplay[i].sPhoneNum = Blank then  
        return;
      end if;

      g_arDisplay[i].sPhoneNum := Blank;
      g_arDisplay[i].sName := Blank; 
      g_arDisplay[i].sStreet := Blank;
      g_arDisplay[i].sTown := Blank;
      g_arDisplay[i].sState := Blank;
      g_arDisplay[i].sZip := Blank;

    end loop;
         
  end;

  procedure ClearWidgetsData;  -- Clear Display  List Screen text boxes
    i : integer;
  begin  

    for i := MinL2 to MaxL2 
    loop
      SetLabelText(i, Chr$(08)); -- 
    end loop;

  end; 

  procedure DisplayCustomersDB; 
  i : integer;
  j : integer;
  begin 
    
    --Makes all selections black
    for i := minL2 to maxL2
    loop
      SetwidgetColor(i, "Black");
    end loop;

    -- Clear Array
    ClearDisplayListArray; 
    
    --Clear the widgets from MinL2 to MaxL2
    ClearWidgetsData;

    -- Sort DB or Get Based of Criteria                                       
    CustomersDB.Sort(2);                                    
    i := 1; 
    
    -- FillArray
    if CustomersDB.GetFirst = SysOk then  

      g_arDisplay[i].sPhoneNum := CustomersDB.PhoneNum;  -- for item 
      g_arDisplay[i].sName := CustomersDB.Name; 
      g_arDisplay[i].sStreet := CustomersDB.Street;
      g_arDisplay[i].sTown := CustomersDB.Town;
      g_arDisplay[i].sState := CustomersDB.State;
      g_arDisplay[i].sZip := CustomersDB.ZipCode;

      i := 2;            

      while CustomersDB.GetNext = SysOk  
      loop         
        if i <= g_ciMaxRecords then             
          g_arDisplay[i].sPhoneNum := CustomersDB.PhoneNum;
          g_arDisplay[i].sName := CustomersDB.Name; 
          g_arDisplay[i].sStreet := CustomersDB.Street;
          g_arDisplay[i].sTown := CustomersDB.Town;
          g_arDisplay[i].sState := CustomersDB.State;
          g_arDisplay[i].sZip := CustomersDB.ZipCode;                     
          i := i + 1;                          
        end if;       
      end loop; 
    end if; 
    
    -- Select Screen, Enable Handlers, Clear Screen and initialize variables                                   
    i := MinL2;  
    SetSymbolState(g_iWidgetNum, 1);
    g_iPage := 1;          
    j := 1;   
    
    -- Populate Screen
    while j <= g_ciMaxPerSelectScreen   
    loop    
      SetLabelText(i, g_arDisplay[j].sName); 
      i := i + 1;
      j := j + 1;   
    end loop;                            

    SetLabelText(Page2, "Page " + IntegerToString(g_iPage,0) + " out of 100");
    SelectScreen(g_ciCust); 
  
  end;    

  procedure ClearProductListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxProducts  -- in the range from 1 to 1000
    loop

      g_arProduct[i].sPSI := 0;
      g_arProduct[i].sQTY_CONC := 0;  
      g_arProduct[i].sSAND_MIX := 0;
      g_arProduct[i].sCEMENT := 0;
      g_arProduct[i].sWAT_GALL := 0;
      g_arProduct[i].sCALCIUM := 0;
      g_arProduct[i].sAIR_ENT := 0;
      g_arProduct[i].sANTIHYDR := 0;
      g_arProduct[i].sRETARDER := 0; 

    end loop;
         
  end;

  procedure FillProductArray; -- fills the product array with information from the database
  i : integer;
  begin
  
    ClearProductListArray;

    --ProductDB.sort(1); commented out for the free flow
    i := 1;

    -- FillArray
    if ProductDB.GetFirst = SysOk then  -- .GetFirst gets the first logical record and it returns a syscode
      g_arProduct[i].sPSI := ProductDB.PSI;
      g_arProduct[i].sQTY_CONC := ProductDB.QTY_CONC;  
      g_arProduct[i].sSAND_MIX := ProductDB.SAND_MIX;
      g_arProduct[i].sCEMENT := ProductDB.CEMENT;
      g_arProduct[i].sWAT_GALL := ProductDB.WAT_GALL;
      g_arProduct[i].sCALCIUM := ProductDB.CALCIUM;
      g_arProduct[i].sAIR_ENT := ProductDB.AIR_ENT;
      g_arProduct[i].sANTIHYDR := ProductDB.ANTIHYDR;
      g_arProduct[i].sRETARDER := ProductDB.RETARDER; 
      i := 2;            
    end if; 
    while ProductDB.GetNext = SysOk  -- .GetNext gets the next record and it returns a syscode 
    loop         
      if i <= g_ciMaxRecords then             
        g_arProduct[i].sPSI := ProductDB.PSI;
        g_arProduct[i].sQTY_CONC := ProductDB.QTY_CONC;  
        g_arProduct[i].sSAND_MIX := ProductDB.SAND_MIX;
        g_arProduct[i].sCEMENT := ProductDB.CEMENT;
        g_arProduct[i].sWAT_GALL := ProductDB.WAT_GALL;
        g_arProduct[i].sCALCIUM := ProductDB.CALCIUM;
        g_arProduct[i].sAIR_ENT := ProductDB.AIR_ENT;
        g_arProduct[i].sANTIHYDR := ProductDB.ANTIHYDR;
        g_arProduct[i].sRETARDER := ProductDB.RETARDER;                                             
        i := i + 1;                          
      end if;       
    end loop; 
    
  end;

  procedure ResetProduct; --Reset the selection screen of the prodct
  i : integer;
  begin
    for i := minL4 to maxL4
    loop
      SetwidgetColor(i, "Black");
    end loop;
  end;

  procedure ResetProductScreen; -- Calls different procedures to reset the product screen with one procedure call
  begin
    ResetProduct;
    ClearProductListArray;
    FillProductArray;
  end;

  procedure setupScreen; -- populate the setup screen 
  i : integer;
  begin
    
    -- setting background bar for screen
    Setbargraphlevel(9,100); 

    --SetImageWidgetPath(btnSetup, "local://11.png");

    SetLabelText(lbl1, "Total amount of batches " + IntegerToString(g_iBatchAcc, 0));
    SetLabelText(lbl2, "Total cement used: " + RealToString(g_rCemAccum,0,0) + " lbs.");
    SetLabelText(lbl3, "Total sand used: " + RealToString(g_rSandAccum,0, 0) + " lbs.");
    SetLabelText(lblLstR, "Last Reset " + lastReset);

  end;

   function GetSelection : integer;  -- Returns the current selected record in the display list    
    -- we choose function because it returns a value 
    i : integer;    
    begin
        if g_iSelect = 53 then   
          g_iWidgetNum := 1;
        elsif g_iSelect = 54 then
          g_iWidgetnum := 2;
        elsif g_iSelect = 55 then
          g_iWidgetNum := 3;
        elsif g_iSelect = 56 then
          g_iWidgetNum := 4;
        elsif g_iSelect = 57 then
          g_iWidgetNum := 5;
        elsif g_iSelect = 58 then
          g_iWidgetNum := 6;
        elsif g_iSelect = 59 then
          g_iWidgetNum := 7;
        elsif g_iSelect = 60 then
          g_iWidgetNum := 8;

        end if;

        i := (g_iPage - 1) * g_ciMaxPerSelectScreen + g_iWidgetNum;  
      
      return i;

    end;

  procedure ClearShipTemp;
  begin
    ts_onsite   := Blank;
    ts_customer := Blank;
    ts_street   := Blank;
    ts_town     := Blank;
    ts_state    := Blank;
    ts_zip      := Blank;
    t_purchase  := Blank;  

  end;

  procedure ClearCustomerTemp;
  begin

    t_phonenum  := Blank;
    t_customer  := Blank;
    t_street    := Blank;
    t_town      := Blank;
    t_state     := Blank;
    t_zip       := Blank;

  end;

  procedure ClearProductTemp;
  begin

    t_psi := 0;
    t_qtyconc := 0;
    t_sand := 0;
    t_cement := 0;
    t_wat_gal := 0;
    t_calcium := 0;
    t_air_ent := 0;
    t_antihydr := 0;
    t_retard := 0;

    r1_select := False;
    r2_select := False;
    r1current_select := 0;
    r2current_select := 0;

  end;

  procedure ClearBillingScreen;
  begin
    SetLabelText(lbl224, Blank);
    SetLabelText(lbl225, Blank);
    SetLabelText(lbl226, Blank);
    SetLabelText(lbl227, Blank);
    SetLabelText(lbl228, Blank);
    SetLabelText(lbl229, Blank);
  end;

  procedure ClearShippingScreen;
  begin
    SetLabelText(lbl328, Blank);
    SetLabelText(lbl335, Blank);
    SetLabelText(lbl330, Blank);
    SetLabelText(lbl331, Blank);
    SetLabelText(lbl332, Blank);
    SetLabelText(lbl333, Blank);
  end;

procedure RunBatch;
  bar_percentage1 : integer := 0;
  bar_percentage2 : integer := 0;
  x : integer;
  y : integer;
  sw : integer := 1;
begin

  --Batching concrete

  --Calculation for target weight
  g_rActive1 := g_rInitial1;

  g_rtarget1 := g_rActive1 - t_cement;
  x := g_rActive1 - g_rtarget1;

  --Batching sand mix
  g_rActive2 := g_rInitial2;

  g_rtarget2 := g_rActive2 - t_sand;
  y := g_rActive2 - g_rtarget2;

  while sw = 1
  loop
    GetGross(1,Primary,g_rActive1);
    x := g_rActive1 - g_rtarget1;
    bar_percentage1 := (x/t_cement) * 100;
    SetBargraphLevel(bar279, bar_percentage1);
    SetLabelText(tarCem, IntegerToString(x,0));

    GetGross(2,Primary,g_rActive2);
    y := g_rActive2 - g_rtarget2;
    bar_percentage2 := (y/t_sand) * 100;
    SetBargraphLevel(bar280, bar_percentage2);
    SetLabelText(tarAg, IntegerToString(y,0));

    if bar_percentage1 <= 0 and bar_percentage2 <= 0 then
      sw := 0;
    end if;
  end loop;

    WaitSS;
end;

handler Timer6Trip;
begin
  EntryMode := BatchMode;
  SetWidgetVisibility(btnNxt9, Voff);
  SelectScreen(g_ciScales);
  RunBatch;
end;

  handler Timer25Trip;  -- Wait for Standstill check
    iMotion1 : integer; 
    iMotion2 : integer;   
    rGrossWgt1 : real;
    rGrossWgt2 : real;
		iInRange1 : integer;
    iInRange2 : integer;
    
  begin

    InMotion(1, iMotion1);
    InMotion(2, iMotion2);
    
    if iMotion1 = 0 and iMotion2 = 0 then  
    
      StopTimer(25);
      DisplayStatus(Blank);  

      g_sysResult1 := GetGross(1, Primary, rGrossWgt1); 
			g_sysResult2 := InRange(1, iInRange1);

      g_sysResult3 := GetGross(2, Primary, rGrossWgt2);
      g_sysResult4 := InRange(2, iInRange2); 
      
			-- Get Gross Command
      if g_sysResult1 <> SysOk then
        DisplayStatus("Scale Error: " + SysCodeToString(g_sysResult1));  
			  return;
      end if;
			
			-- Check In Range
      if g_sysResult3 <> SysOk then
        DisplayStatus("Scale Error: " + SysCodeToString(g_sysResult3));  
			  return;
      end if;			
			
		 -- Validate InRage
		 if iInRange1 = 0 then  
        DisplayStatus("Scale 1 NOT In Range");  
				return;
		 end if;

		 if iInRange2 = 0 then  
        DisplayStatus("Scale 2 NOT In Range");  
				return;
		 end if;
    

      if EntryMode = BatchCompleteMode then  -- Print Screen
        
        TransDB.DT := SystemTime; 
        TransDB.T_Cem := RealToString(rGrossWgt1, 0, 2);
        TransDB.T_Sand := RealToString(rGrossWgt2, 0, 2);
        TransDB.Yards := RealToString(t_qtyconc, 0, 2);
        TransDB.Product := IntegerToString(t_psi, 0) + RealToString(t_qtyconc, 0, 2);
        g_sysResult := TransDB.Add;
        
        if g_sysResult = SysOk then      

          DisplayStatus(RealToString(rGrossWgt1, 0, 2));

        else 
          DisplayStatus("Database Error: " + SysCodeToString(g_sysResult1)); 					
        end if; 

      elsif EntryMode = BatchReadyMode then
        g_rInitial1 := rGrossWgt1;
        g_rInitial2 := rGrossWgt2;
        EntryMode := LoadMode;
        SelectScreen(g_ciLoad);
        SetupStartTimer(6,500,TimerOneShot);
        --EntryMode := BatchMode;
        --SetWidgetVisibility(btnNxt9, Voff);
        --SelectScreen(g_ciScales);
        --RunBatch;

      elsif EntryMode = BatchMode then
        if FileExists("/sdimages/next.png", SDCard) = SysOk then
          SetImageWidgetPath(btnNxt9, "/next.png");
        else
          SetImageWidgetPath(btnNxt9, "local://10.png");
        end if;
        g_rEnd1 := rGrossWgt1;
        g_rEnd2 := rGrossWgt2;
        g_rcembatch := g_rInitial1 - g_rEnd1;
        g_rsandbatch  := g_rInitial2 - g_rEnd2;
        g_rCemAccum := g_rCemAccum + g_rcembatch;
        g_rSandAccum := g_rSandAccum + g_rsandbatch;
        g_iBatchAcc := g_iBatchAcc + 1;
        g_iTicketNum := g_iTicketNum + 1;
        SetWidgetVisibility(btnNxt9, Von); 
        DisplayStatus("Batch Complete!");
        EntryMode := NoMode;
      end if;  
    else
      DisplayStatus("...In Motion...");  
    end if;

  end;

  procedure PageUporDownCustomerList(tmpPage : integer);  -- Page Up/Page Down the Display List 
    a : integer;
    i : integer;
    j : integer;
    b : integer;
  begin 
    
    -- Clear display
    for i := MinL2 to MaxL2
    loop
      SetLabelText(i, Blank);
    end loop;
    
    -- Find out where we are in the array
    if tmpPage = 1 then
      i := 1;                          -- g_ciMaxRecords MUST BE MULTIPLE OF 8
    elsif tmpPage >= 2 and tmpPage <= (g_ciMaxRecords/g_ciMaxPerSelectScreen) then
      i := (tmpPage * g_ciMaxPerSelectScreen) - 7;      
    else
      i := 1;
      g_iPage := 1;              
    end if;

    b := MinL2;
    j := i + 7; 
    
    -- Display the top of the list if we have reach the end 
    if g_arDisplay[i].sPhoneNum = Blank then --and EntryMode <> CustomerSelectMode then
 
      DisplayCustomersDB;  

    else  
      
    -- Populate display with new data
    for a := i to j
    loop  
      if a > 0 and a <= g_ciMaxRecords then--and g_arDisplay[a].sPhoneNum <> Blank then
        SetLabelText(b, g_arDisplay[a].sName); 
        b := b + 1; 
      end if; 
    end loop;
       
    end if;
  
  SetLabelText(Page2, "Page " + IntegerToString(g_iPage,0) + " out of 100");

end;   

  procedure SelectProduct;
    i : integer;
  begin
  --r1 = BTN 108-113
  --r2 = BTN 114-117

    g_iProductRow := 0;

   --R1
    if g_iWidget >= 108 and g_iWidget <= 113 then 
      if r1_select = True and r1current_select = g_iWidget then 
        r1_select := False;
        SetWidgetColor(r1current_select, "Black");
        r1current_select := 0;
      elsif r1_select = True and r1current_select <> g_iWidget then
        SetWidgetColor(r1current_select, "Black");
        r1current_select := g_iWidget;
        SetWidgetColor(g_iWidget, "Red");
      else 
        r1_select := True;
        SetWidgetColor(g_iWidget, "Red");
        r1current_select := g_iWidget;
      end if;
    end if;


    --R2
    if g_iWidget >= 114 and g_iWidget <= 117 then 
      if r2_select = true and r2current_select = g_iWidget then 
        r2_select := False;
        SetWidgetColor(r2current_select, "Black");
        r2current_select := 0;
      elsif r2_select = True and r2current_select <> g_iWidget then
        SetWidgetColor(r2current_select, "Black");
        r2current_select := g_iWidget;
        SetWidgetColor(g_iWidget, "Red");
      else 
        r2_select := True;
        SetWidgetColor(g_iWidget, "Red");
        r2current_select := g_iWidget;
      end if;
    end if;

    if r1_select = true and r2_select = true then
      SetWidgetVisibility(btnNxt, Von);
    else
      SetWidgetVisibility(btnNxt, Voff);
    end if; 

  end;

  procedure GetProductSelection;
  begin
    if r1current_select = 108 and r2current_select = 114 then --1 2500
      g_iProductRow := 1;
    elsif r1current_select = 108 and r2current_select = 115 then --2
      g_iProductRow := 2;
    elsif r1current_select = 108 and r2current_select = 116 then --3
      g_iProductRow := 3;
    elsif r1current_select = 108 and r2current_select = 117 then --4
      g_iProductRow := 4;
    elsif r1current_select = 109 and r2current_select = 114 then --1 3000
      g_iProductRow := 5;
    elsif r1current_select = 109 and r2current_select = 115 then --2
      g_iProductRow := 6;
    elsif r1current_select = 109 and r2current_select = 116 then --3
      g_iProductRow := 7;
    elsif r1current_select = 109 and r2current_select = 117 then --4
      g_iProductRow := 8;
    elsif r1current_select = 110 and r2current_select = 114 then --1 3500
      g_iProductRow := 9;
    elsif r1current_select = 110 and r2current_select = 115 then --2
      g_iProductRow := 10;
    elsif r1current_select = 110 and r2current_select = 116 then --3
      g_iProductRow := 11;
    elsif r1current_select = 110 and r2current_select = 117 then --4
      g_iProductRow := 12;
    elsif r1current_select = 111 and r2current_select = 114 then --1 4000
      g_iProductRow := 13;
    elsif r1current_select = 111 and r2current_select = 115 then --2
      g_iProductRow := 14;
    elsif r1current_select = 111 and r2current_select = 116 then --3
      g_iProductRow := 15;
    elsif r1current_select = 111 and r2current_select = 117 then --4
      g_iProductRow := 16;
    elsif r1current_select = 112 and r2current_select = 114 then --1 5000
      g_iProductRow := 17;
    elsif r1current_select = 112 and r2current_select = 115 then --2
      g_iProductRow := 18;
    elsif r1current_select = 112 and r2current_select = 116 then --3
      g_iProductRow := 19;
    elsif r1current_select = 112 and r2current_select = 117 then --4
      g_iProductRow := 20;
    elsif r1current_select = 113 and r2current_select = 114 then --1 Free Flow
      g_iProductRow := 21;
    elsif r1current_select = 113 and r2current_select = 115 then --2
      g_iProductRow := 22;
    elsif r1current_select = 113 and r2current_select = 116 then --3
      g_iProductRow := 23;
    elsif r1current_select = 113 and r2current_select = 117 then --4
      g_iProductRow := 24;
    else
      DisplayStatus("System Malfunction!");
      g_iProductRow := 0;
    end if;

  end;


  procedure LoadProduct;
  i : integer;
  begin
    
    if g_iProductRow <> 0 then
      t_psi       := g_arProduct[g_iProductRow].sPSI;
      t_qtyconc   := g_arProduct[g_iProductRow].sQTY_CONC;
      t_sand      := g_arProduct[g_iProductRow].sSAND_MIX;
      t_cement    := g_arProduct[g_iProductRow].sCEMENT;
      t_wat_gal   := g_arProduct[g_iProductRow].sWAT_GALL;
      t_calcium   := g_arProduct[g_iProductRow].sCALCIUM;
      t_air_ent   := g_arProduct[g_iProductRow].sAIR_ENT;
      t_antihydr  := g_arProduct[g_iProductRow].sANTIHYDR;
      t_retard    := g_arProduct[g_iProductRow].sRETARDER;
          

    else
      DisplayStatus("ERROR! No Selection Made.");
    end if;

    r1current_select := 0;
    r2current_select := 0;
  end;

  procedure ProcessSelection;

  begin
    if g_iSelect <> 0 then
      if EntryMode = CustomerSelectMode then
        if g_arDisplay[GetSelection].sName <> Blank then   
          t_customer := g_arDisplay[GetSelection].sName;
          t_phonenum := g_arDisplay[GetSelection].sPhoneNum;
          t_street   := g_arDisplay[GetSelection].sStreet;
          t_town     := g_arDisplay[GetSelection].sTown;
          t_state    := g_arDisplay[GetSelection].sState;
          t_zip      := g_arDisplay[GetSelection].sZip;
        else 
          DisplayStatus("Error: Please Enter A Customer");
          g_iSelect := 0;
        end if;
      end if;
    else
      Displaystatus("Select An Entry to Continue");
      EntryMode :=  CustomerSelectMode;
      g_iSelect := 0;    
    end if;

  end;

  procedure SelectCustomer;
  i : integer;
  begin
    for i := minL2 to maxL2
    loop
      SetwidgetColor(i, "Black");
    end loop;
  -- if the number of the widget is divided by 2, the remainder will determine what button is turned 
    if g_iWidget <> g_iSelect and g_iSelect <> 0 then
      SetWidgetColor(g_iSelect, "Black");
      SetWidgetColor(g_iWidget, "Red");
      g_iSelect := g_iWidget;
    else
      Setwidgetcolor(g_iWidget, "Red");
      g_iSelect := g_iWidget;
    end if;
    ProcessSelection;
  end;

  procedure DeleteCustomer;
  begin

    if g_iSelect <> 0 then
      if EntryMode = CustomerSelectMode then
        CustomersDB.Name := g_arDisplay[GetSelection].sName;
        if CustomersDB.FindFirst(2) = SysOk then        
          EntryMode := YNClearOneMode;
          SelectScreen(g_ciYN);         
          Setlabeltext(lbMsg1,"Do you want to delete " + CustomersDB.Name + "?");
        else 
          DisplayStatus("Error: Invalid CUSTOMER");
        end if;
      end if;
    else
      Displaystatus("Select One to Delete");
    end if;

  end;

  procedure ProcessDataEntry(sTemp : string); --Processes different data entries based on the entry mode the program is in
  begin
    --This is only going to show up for new customer entries
    if g_Entrymode = EnterPhoneMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Order Number - Retry", EnterPhoneMode, Blank, 2);
      end if;
      t_phonenum := sTemp;
      SetLabelText(lbl224, t_phonenum);
      EntryMode := CustomerProcessMode;
        
    elsif g_Entrymode = EnterNameMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Customer Entry - Retry", EnterNameMode, Blank, 1);
      end if;
      SetLabelText(lbl225, sTemp);
      t_customer := sTemp;
      EntryMode := CustomerProcessMode;

    elsif g_Entrymode = EnterStreetMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Street Entry - Retry", EnterStreetMode, Blank, 1);
      end if;
      SetLabelText(lbl226, sTemp);
      t_street := sTemp;
      EntryMode := CustomerProcessMode;

    elsif g_Entrymode = EnterTownMode then
      if sTemp = Blank then
      
        PromptForEntry("Invalid Town Entry - Retry", EnterTownMode, Blank, 1);
      end if; 
      SetLabelText(lbl227, sTemp);
      t_town := sTemp;
      EntryMode := CustomerProcessMode;
    
    elsif g_Entrymode = EnterStateMode then 
      if sTemp = Blank then
      
        PromptForEntry("Invalid State Entry - Retry", EnterStateMode, Blank, 1);
      end if;
      SetLabelText(lbl228, sTemp);
      t_state := sTemp;
      EntryMode := CustomerProcessMode;
    
    elsif g_Entrymode = EnterZipCodeMode then
      if sTemp = Blank then
      
        PromptForEntry("Invalid Zip Code Entry - Retry", EnterZipCodeMode, Blank, 2); 
      end if;
      SetLabelText(lbl229, sTemp);
      t_zip := sTemp;
      EntryMode := CustomerProcessMode;
    
    elsif g_Entrymode = EnterOnsiteTelMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Phone Number Entry - Retry", EnterOnsiteTelMode, Blank, 2); 
      end if;
      SetLabelText(lbl328, sTemp);
      ts_onsite := sTemp;
      EntryMode := ShippingMode;

    elsif g_EntryMode = EnterShipCustomerMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Customer Entry - Retry", EnterShipCustomerMode, Blank, 1);
      end if;
      SetLabelText(lbl335, sTemp);
      ts_customer := sTemp;
      EntryMode := ShippingMode; 

    elsif g_Entrymode = EnterShipStreetMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Street Entry - Retry", EnterShipStreetMode, Blank, 1);
      end if;
      SetLabelText(lbl330, sTemp);
      ts_street := sTemp;
      EntryMode := ShippingMode;

    elsif g_Entrymode = EnterShipTownMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Town Entry - Retry", EnterShipTownMode, Blank, 1);
      end if; 
      SetLabelText(lbl331, sTemp);
      ts_town := sTemp;
      EntryMode := ShippingMode;
    
    elsif g_Entrymode = EnterShipStateMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid State Entry - Retry", EnterShipStateMode, Blank, 1);
      end if;
      SetLabelText(lbl332, sTemp);
      ts_state := sTemp;
      EntryMode := ShippingMode;
    
    elsif g_Entrymode = EnterShipZipCodeMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Zip Code Entry - Retry", EnterShipZipCodeMode, Blank, 2); 
      end if;
      SetLabelText(lbl333, sTemp);
      ts_zip := sTemp;
      EntryMode := ShippingMode;
    
    elsif g_EntryMode = EnterNewPasswordMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Password Entry - Retry", EnterNewPasswordMode, Blank, 3);
      else
        g_sTmpPassword := sTemp;
        sPassword := g_sTmpPassword;
        EntryMode:= SetupMenuMode;
        setupScreen;
        SelectScreen(g_ciSetup); 
      end if;
    
    elsif g_EntryMode = EnterPasswordMode then
      if sTemp = sPassword or sTemp = backdoor_pass then
        locked := False;
        EntryMode:= SetupMenuMode;
        setupScreen;
        SelectScreen(g_ciSetup);
      else
        PromptForEntry("Invalid Password Entry - Retry", EnterPasswordMode, Blank, 3); 
      end if;

    elsif g_EntryMode = EnterPurchaseOrderMode then 
      if sTemp = Blank then 
        PromptForEntry("Invalid: To Continue Enter Purchase Order", EnterPurchaseOrderMode, Blank, 1);
      end if;
      t_purchase := sTemp;
      EntryMode := ProductSelectMode;
      if FileExists("/sdimages/next.png", SDCard) = SysOk then
        SetImageWidgetPath(btnNxt, "/next.png");
      else
        SetImageWidgetPath(btnNxt, "local://10.png");
      end if;
      SetWidgetVisibility(btnNxt, Voff);
      ResetProduct;
      FillProductArray;
      SelectScreen(g_ciProduct);      
    end if;
  end;

  handler Timer4Trip;
  begin
    SelectScreen(g_ciCust); 
  end;

procedure ProcessingCustomerEntry;
begin
    CustomersDB.PhoneNum := t_phonenum; -- we are temporarily setting the value of t_phonenum to the database 
    CustomersDB.Name := t_customer;
    CustomersDB.Street := t_street;
    CustomersDB.Town := t_town;
    CustomersDB.State := t_state;
    CustomersDB.ZipCode := t_zip;

    g_sysResult := CustomersDB.FindFirst(Customer_Name); --This will equal SysOk if found in DB
    if g_sysResult <> SysOk then
      CustomersDB.Add;
      EntryMode := CustomerSelectMode;
      DisplayCustomersDB;
      ClearCustomerTemp;
      if FileExists("/sdimages/next.png", SDCard) = SysOk then  
        SetImageWidgetPath(btnNxt2, "/next.png");
      else
        SetImageWidgetPath(btnNxt2, "local://10.png");
      end if;
      SetupStartTimer(4,100,TimerOneShot);
    elsif g_sysResult = SysDatabaseFull then
      Delete25Percent;
      CustomersDB.Add;
      EntryMode := CustomerSelectMode;
      g_Entrymode := CustomerSelectMode;
      DisplayCustomersDB;
      if FileExists("/sdimages/next.png", SDCard) = SysOk then  
        SetImageWidgetPath(btnNxt2, "/next.png");
      else
        SetImageWidgetPath(btnNxt2, "local://10.png");
      end if;
      SetupStartTimer(4,100,TimerOneShot);
    else
      DisplayStatus("ERROR! CUSTOMER ALREADY EXISTS! PLEASE SELECT THE CUSTOMER FROM THE PREVIOUS SCREEN!");
    end if;
end;

procedure CheckBatch;
begin

  GetGross(1,Primary,g_rInitial1);
  GetGross(2,Primary,g_rInitial2);
  
  if g_rInitial1 < t_cement then
    Displaystatus("ERROR! NOT ENOUGH MATERIAL ON SCALE 1!");
    SetLabelText(lbStat, "Please put " + RealToString(t_cement, 0, 0) + " on cement scale!");
    SetWidgetVisibility(lbStat, Von);
  elsif g_rInitial2 < t_sand then
    DisplayStatus("ERROR! NOT ENOUGH MATERIAL ON SCALE 2!");
    SetLabelText(lbStat, "Please put " + RealToString(t_sand, 0, 0) + " on aggregate scale!");
    SetWidgetVisibility(lbStat, Von);
  else
    WaitSS;
  end if;
    
end;

handler UserEntry; -- Built in and 
  sTemp : string;
begin
  sTemp := GetEntry; -- is the action of getting user entry
  ClosePrompt;
  
  if EventKey = EnterKey then
    ProcessDataEntry(sTemp);
  else
    ProcessPromptCancel;
  end if;

end;


procedure Ready;  -- Initialization procedure
begin

  if FileExists("/sdimages/ASC.png", SDCard) = SysOk then  
    SetImageWidgetPath(img4, "/ASC.png");
    SetWidgetVisibility(img4, Von);
  else
    SetWidgetVisibility(img4, VOff);
  end if;
  
  LockKey(NavUpKey);
  LockKey(NavDownKey);
  setupScreen;
  bar_string := "";
   
  if GetUnits(1, g_uUnits) = SysOk then
    if GetCountBy(1, g_uUnits, g_rCountby) = SysOk then
      g_iDecimal1 := CalcDecimal(g_rCountby); 
    end if;
  end if; 

  r1_select := False;
  r2_select := False;
  EntryMode := NoMode;
  SelectScreen(g_ciMain); 
  
end;

procedure DefaultsForAddOns;
begin

  Setwidgetcolor(lbl127, "Black");
  Setwidgetcolor(lbl136, "Black");
  Setwidgetcolor(lbl132, "Black");
  Setwidgetcolor(lbl141, "Black");

  bCalcium := False;
  bAnti_hydro := False;
  bAir_ent := False;
  bRetarder := False;

  Setwidgetcolor(lbl128, "Red");
  Setwidgetcolor(lbl137, "Red");
  Setwidgetcolor(lbl133, "Red");
  Setwidgetcolor(lbl142, "Red");

end;

procedure CancelBatch;
begin
  ClearCustomerTemp;
  ClearProductTemp;
  ClearShippingScreen;
  ClearShipTemp;
  EntryMode := NoMode;
  SelectScreen(g_ciMain);
end;

procedure TicketOutput;
  --dTime : datetime := SystemTime;
  line0 : string;
  line1 : string;
  line2 : string;
  line3 : string;
  line4 : string;
  line5 : string;
  line6 : string;
  line7 : string;
  line8 : string;
  line9 : string;
  line10: string;
  length0 : integer; 
  length1 : integer;
  length2 : integer;
  length3 : integer;
  length4 : integer;
  length5 : integer;
  length6 : integer;
  length7 : integer;
  length8 : integer;
  length9 : integer;
  length10: integer;
begin

  DisplayStatus("Printing...");
  SetupStartTimer(3,500,TimerOneShot);

  line0 := "Order #: " + IntegerToString(g_iTicketNum, 0);
  length0 := Len(line0);
  if length0 < 55 then
    WriteLn(g_ciPrinter, line0 + Space$(55-length0) + "PO #: " + t_purchase);
  end if;

  WriteLn(g_ciPrinter, Space$(25) + "*****************************");
  --WriteLn(g_ciPrinter, Space$(25) + "CAVALIERE/SHORT LOAD CONCRETE");
  WriteLn(g_ciPrinter, Space$(25) + "SHORT LOAD CONCRETE");
  --WriteLn(g_ciPrinter, Space$(31) + "226 Selleck St C");
  WriteLn(g_ciPrinter, Space$(31) + "53 Warfield St");
  --WriteLn(g_ciPrinter, Space$(30) + "Stamford, CT, 06902");
  WriteLn(g_ciPrinter, Space$(30) + "Milford, CT, 06461");
  WriteLn(g_ciPrinter, Space$(32) + "(866)746-7853"); --Delete this line for the Calvaliere Site
  WriteLn(g_ciPrinter, Space$(25) + "*****************************");
  WriteLn(g_ciPrinter, Blank);

  line1 := "SHIPPING INFO";
  length1 := Len(line1);
  if length1 < 40 then
    WriteLn(g_ciPrinter, line1 + Space$(40-length1) + "BILLING INFO");
  end if;

  line2 := "Customer: " + ts_customer;
  length2 := Len(line2);
  if length2 < 40 then
    WriteLn(g_ciPrinter, line2 + Space$(40-length2) + "Customer: " + t_customer);
  end if;
  
  line3 := "Shipping Address: ";
  length3 := Len(line3);
  if length3 < 40 then
    WriteLn(g_ciPrinter, line3 + Space$(40-length3) + "Billing Address: ");
  end if;
  
  line4 := ts_street;
  length4 := Len(line4);
  if length4 < 40 then
    WriteLn(g_ciPrinter, line4 + Space$(40-length4) + t_street);
  end if;
  
  line5 := ts_town + "," + ts_state;
  length5 := Len(line5);
  if length5 < 40 then
    WriteLn(g_ciPrinter, line5 + Space$(40-length5) + t_town + "," + t_state);
  end if;

  line6 :="Onsite #: " + ts_onsite;
  length6 := Len(line6);
  if length6 < 40 then
    WriteLn(g_ciPrinter, line6 + Space$(40-length6) + "Phone #: " + t_phonenum);
  end if;
    

  WriteLn(g_ciPrinter, Blank);
  WriteLn(g_ciPrinter, Space$(5) + "MIX DESCRIPTION" + Space$(35) + "ADD ONS");
  WriteLn(g_ciPrinter, "**************************" + Space$(14) + "***********************************");

  if t_psi = 1 then
    line7 := "PSI: Free Flow";
  else
    line7 :="PSI: " + IntegerToString(t_psi,0);
  end if;
  length7 := Len(line7);
  if bCalcium = true then 
    if length7 < 40 then
      WriteLn(g_ciPrinter, line7 + Space$(40-length7) + "Calcium: " + IntegerToString(t_calcium,0) + " lbs.");
    end if;
  else 
    WriteLn(g_ciPrinter, line7);
  end if;   

  line8 := "Quantity of Concrete: " + RealToString(t_qtyconc, 4, 1) + " yds.";
  length8 := Len(line8);
  if bAnti_hydro = true then 
    if length8 < 40 then
      WriteLn(g_ciPrinter, line8 + Space$(40-length8) + "Anti Hydro: " + RealToString(t_antihydr,4,2) + " gals/CYs");
    end if;
  else 
    WriteLn(g_ciPrinter, line8);
  end if;   

  line9 := "Sand & Stone Mix: " + RealToString(g_rsandbatch, 4, 0) + " lb.";
  length9 := Len(line9);
  if bAir_ent = true then 
    if length9 < 40 then
      WriteLn(g_ciPrinter, line9 + Space$(40-length9) + "Air Entrainment: " + RealToString(t_air_ent,4,2) + " oz.");
    end if;
  else 
    WriteLn(g_ciPrinter, line9 );
  end if;   

  line10 := "Cement: " + RealToString(g_rcembatch, 4, 0) + " lb.";
  length10 := Len(line10);
  if bRetarder = true then 
    if length10 < 40 then
      WriteLn(g_ciPrinter, line10 + Space$(40-length10) + "Retarder: " + RealToString(t_retard,6,2) + " oz.");
    end if;
  else 
    WriteLn(g_ciPrinter, line10);
  end if;   

  WriteLn(g_ciPrinter, "Water: " + RealToString(t_wat_gal, 5, 0) + " gal.");
  WriteLn(g_ciPrinter, Blank);
  WriteLn(g_ciPrinter, Blank);
  WriteLn(g_ciPrinter, "Auth. Signature ______________________________________");
  WriteLn(g_ciPrinter, Blank);
  WriteLn(g_ciPrinter, Space$(5) + "By signing this ticket buyer has agreed to the Terms and Conditions");
  WriteLn(g_ciPrinter, Space$(5) + "which are located at www.shortloadconcrete.net");

end;

handler Timer3Trip;
begin
  DisplayStatus(Blank);
end;


handler Cmd2Handler;
begin
  while StartStreaming(2) = SysOk
    bar_string := EventString

end;


handler Port2CharReceived;
begin
   
  while StartStreaming(2) = SysOk 
  loop
    if EventChar <> "" then
      bar_string := bar_string + EventChar;
    else
      exit;
    end if;
  end loop;

  StopStreaming(2);
  --bar_string := temp_S;

  Setlabeltext(lbl225, bar_string);
  DisableHandler(Port2CharReceived);
end;

procedure DisplayBatchComplete;
begin
  if EntryMode = BatchCompleteMode then

    --dTime := SystemTime;
    SetLabelText(lblCust, ts_customer);  -- Shipping or Billing Customer Variable?
    SetLabelText(lblShp1, ts_street);
    SetLabelText(lblShp2, ts_town);
    SetLabelText(lblShp3, ts_state);
    if t_psi = 1 then
      SetLabelText(lblProd, RealToString(t_qtyconc,1,1) + " Yards " + "FREE FLOW");
    else
      SetLabelText(lblProd, RealToString(t_qtyconc,1,1) + " Yards " + IntegerToString(t_psi,0) + " PSI");
    end if;
    SetLabelText(lbl275, RealToString(t_qtyconc,1,1) + " Yards");
  end if;
end;

handler WidgetClicked;
  begin

  	DisableHandler(WidgetClicked);
		g_iWidget := EventWidget;
		DisplayStatus("");

    if g_iWidget = btnStrt then
      EntryMode := CustomerSelectMode;
      DisplayCustomersDB;
      if FileExists("/sdimages/next.png", SDCard) = SysOk then  
        SetImageWidgetPath(btnNxt2, "/next.png");
      else
        SetImageWidgetPath(btnNxt2, "local://10.png");
      end if;
      SelectScreen(g_ciCust);

    -- this allows for a range of widget numbers for a selection screen (for Customer Selection Screen)
    elsif g_iWidget >= MinL2 and g_iWidget <= MaxL2 then
      SelectCustomer;
    
    elsif g_iWidget = btnNxt2 then
    if g_iSelect <> 0 then
      CustomersDB.Name := g_arDisplay[GetSelection].sName;
      if CustomersDB.FindFirst(2) = SysOK then
        EntryMode := YNShippingAddress;
        SelectScreen(g_ciYN);
        SetLabelText(lbMsg1, "Is the shipping address");
        SetLabelText(lbMsg2, "the same as billing?");
      else
        DisplayStatus("Error: Invalid Selection");
      end if;
    end if;

    elsif g_iWidget = lbl10 then --Cancel Button
      StopTimer(6);
      CancelBatch;

    elsif g_iWidget = btnCont2 or g_iWidget = btnCont1 then
      if t_phonenum = Blank or len(t_phonenum) < 10 then
        DisplayStatus("ERROR! INVALID ONSITE TEL. FIELD!");
      elsif t_customer = Blank then
        DisplayStatus("ERROR! PLEASE FILL OUT CUSTOMER FIELD!");
      elsif t_street = Blank then
        DisplayStatus("ERROR! PLEASE FILL OUT STREET FIELD!");  
      elsif t_town = Blank then
        DisplayStatus("ERROR! PLEASE FILL OUT TOWN FIELD!");
      elsif t_state = Blank or len(t_state) <> 2 then
        DisplayStatus("ERROR! PLEASE FILL OUT STATE FIELD WITH THE APPROPRIATE ABBREVIATION!");      
      elsif len(t_zip) < 5 then
        DisplayStatus("ERROR! INVALID ZIP CODE FIELD!");
      else
        if EntryMode = CustomerProcessMode then
          ProcessingCustomerEntry;
        end if;
      end if;
      

    elsif g_iWidget = btnSub1 or g_iWidget = btnSub2 then
      if ts_onsite = Blank or len(ts_onsite) < 10 then
        DisplayStatus("ERROR! INVALID ONSITE TEL. FIELD!");
      elsif ts_customer = Blank then
        DisplayStatus("ERROR! PLEASE FILL OUT CUSTOMER FIELD!");
      elsif ts_street = Blank then
        DisplayStatus("ERROR! PLEASE FILL OUT STREET FIELD!");
      elsif ts_town = Blank then
        DisplayStatus("ERROR! PLEASE FILL OUT TOWN FIELD!");
      elsif ts_state = Blank or len(ts_state) <> 2 then
        DisplayStatus("ERROR! PLEASE FILL OUT STATE FIELD!");
      elsif len(ts_zip) < 5 then
        DisplayStatus("ERROR! INVALID ZIP CODE FIELD!");
      else
        EntryMode := EnterPurchaseOrderMode;
        PromptForEntry("Please Enter a Purchase Order", EnterPurchaseOrderMode, Blank, 1);
      end if;

    elsif g_iWidget >= minL4 and g_iWidget <= maxL4 then
      SelectProduct;

    elsif g_iWidget = btnExt2 then
      if EntryMode = CustomerSelectMode then
        EntryMode := NoMode;
        g_iSelect := 0;
        SelectScreen(g_ciMain);
      end if;

    elsif g_iWidget = btnExt4 then
      EntryMode := CustomerSelectMode;
      ClearProductTemp;
      ClearShipTemp;
      ClearShippingScreen;
      DisplayCustomersDB;
      g_iSelect := 0;
      SelectScreen(g_ciCust);
 
    elsif g_iWidget = btnPrint then  
      TicketOutput;

    elsif g_iWidget = btnDone then
      ClearCustomerTemp;
      ClearProductTemp;
      ClearShipTemp;
      ClearBillingScreen;
      ClearShippingScreen;
      EntryMode := NoMode;
      g_iSelect := 0;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnExt8 then
      EntryMode := CustomerSelectMode;
      ClearCustomerTemp;
      ClearBillingScreen;
      DisplayCustomersDB;
      g_iSelect := 0;
      SelectScreen(g_ciCust);

    elsif g_iWidget = btnExt10 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnExt3 then
      EntryMode := CustomerSelectMode;
      ClearShipTemp;
      ClearShippingScreen;
      g_iSelect := 0;
      DisplayCustomersDB;
      SelectScreen(g_ciCust);
    
    elsif g_iWidget = btnSetup then
      if sPassword = Blank then
        PromptForEntry("Enter A New Password", EnterNewPasswordMode, Blank,3);
      else
        PromptForEntry("Enter Password", EnterPasswordMode, Blank,3);
      end if;

    elsif g_iWidget = btnNxt then
      if FileExists("/sdimages/next.png", SDCard) = SysOk then
        SetImageWidgetPath(btnNxt13, "/next.png");
      else
        SetImageWidgetPath(btnNxt13, "local://10.png");
      end if;
      GetProductSelection;
      LoadProduct; 
      if g_iProductRow <> 0 then
        EntryMode := AddOnsMode;
        SelectScreen(g_ciAddOns); 
        DefaultsForAddOns;
      end if;
      
      -- (Note: we dont want to create lockup: which is a gridlock)
    
    elsif g_iWidget = btnNxt13 then
      --This stays here
      EntryMode := BatchReadyMode;
      SetWidgetVisibility(lbStat, VOff);
      SelectScreen(g_ciBatchReady);

    elsif g_iWidget = btnBatch then
      if EntryMode = BatchReadyMode then
        CheckBatch;
      end if;

    elsif g_iWidget = btnNxt9 then
      EntryMode := BatchCompleteMode;
      DisplayBatchComplete;
      SelectScreen(g_ciBatch);

    elsif g_iWidget = btnExt13 then
      EntryMode := ProductSelectMode;
      ResetProductScreen;
      SelectScreen(g_ciProduct);

    elsif g_iWidget = lbl127 then
      if  bCalcium = False then
        SetWidgetColor(lbl128, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bCalcium := True;
      end if;
      
    elsif g_iWidget = lbl128 then 
      if bCalcium = True then 
        SetWidgetColor(lbl127, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bCalcium := False;
      end if;

    elsif g_iWidget = lbl132 then
      if  bAir_ent = False then
        SetWidgetColor(lbl133, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bAir_ent := True;
      end if;

    elsif g_iWidget = lbl133 then
      if  bAir_ent = True then
        SetWidgetColor(lbl132, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bAir_ent := False;
      end if;

    elsif g_iWidget = lbl136 then
      if  bAnti_hydro= False then
        SetWidgetColor(lbl137, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bAnti_hydro := True;
      end if;
    
    elsif g_iWidget = lbl137 then
      if  bAnti_hydro= True then
        bAnti_hydro := False;
        SetWidgetColor(lbl136, "Black");
        SetWidgetColor(g_iWidget, "Red");
      end if;

    elsif g_iWidget = lbl141 then
      if  bRetarder = False then
        SetWidgetColor(lbl142, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bRetarder := True;
      end if;
    
    elsif g_iWidget = lbl142 then
      if  bRetarder = True then
        SetWidgetColor(lbl141, "Black");
        SetWidgetColor(g_iWidget, "Red");
        bRetarder := False;
      end if;

    elsif g_iWidget = lbl224 then
      PromptForEntry("Enter Phone Number", EnterPhoneMode, Blank,2);

    elsif g_iWidget = lbl225 then
      PromptForEntry("Enter Customer Name", EnterNameMode, Blank,1);
    
    elsif g_iWidget = lbl226 then
      PromptForEntry("Enter Street", EnterStreetMode, Blank,1);

    elsif g_iWidget = lbl227 then
      PromptForEntry("Enter Town", EnterTownMode, Blank,1);

    elsif g_iWidget = lbl228 then
      PromptForEntry("Enter State", EnterStateMode, Blank,1);

    elsif g_iWidget = lbl229 then
      PromptForEntry("Enter Zipcode", EnterZipCodeMode, Blank,2);
    
    elsif g_iWidget = lbl328 then
      PromptForEntry("Enter Onsite Phone", EnterOnsiteTelMode, Blank,2);
    
    elsif g_iWidget = lbl335 then
      PromptForEntry("Enter Customer Name", EnterShipCustomerMode, Blank,1);
    
    elsif g_iWidget = lbl330 then
      PromptForEntry("Enter Street", EnterShipStreetMode, Blank,1);

    elsif g_iWidget = lbl331 then
      PromptForEntry("Enter Town", EnterShipTownMode, Blank,1);
    
    elsif g_iWidget = lbl332 then
      PromptForEntry("Enter State", EnterShipStateMode, Blank,1);
    
    elsif g_iWidget = lbl333 then
      PromptForEntry("Enter ZipCode", EnterShipZipCodeMode, Blank,2);
    
    elsif g_iWidget = btnAdd then
      EntryMode := CustomerProcessMode;
      ClearBillingScreen;
      SelectScreen(g_ciaddcust);
    elsif g_iWidget = btnPgUp2 then
      g_iPage := g_iPage - 1;   
      SetSymbolState(g_iWidgetNum, 2);      
      PageUporDownCustomerList(g_iPage);  

    elsif g_iWidget = btnPgDn2 then
      g_iPage := g_iPage + 1;   
      SetSymbolState(g_iWidgetNum, 2);       
      PageUporDownCustomerList(g_iPage); 

    elsif g_iWidget = btnExt13 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = btnDelet then
      DeleteCustomer;

    elsif g_iWidget = btnYes5 then
      if EntryMode = YNShippingAddress then
        ts_onsite := t_phonenum;
        ts_customer := t_customer;
        ts_street := t_street;
        ts_town := t_town;
        ts_state := t_state;
        ts_zip := t_zip;
        EntryMode := EnterPurchaseOrderMode;
        PromptForEntry("Please Enter a Purchase Order", EnterPurchaseOrderMode, Blank, 1);
      elsif EntryMode = YNClearOneMode then
        g_sysResult := CustomersDB.Delete;
        if g_sysResult = SysOk then
          EntryMode := CustomerSelectMode;
          DisplayStatus("Loading Customers...");
          DisplayCustomersDB; 
          DisplayStatus("Selection Deleted");  
        else    
          EntryMode := CustomerSelectMode;
          DisplayStatus("Loading Customers...");
          DisplayCustomersDB;     
          DisplayStatus("Database Error: " + SysCodeToString(g_sysResult));
        end if;
      end if; 
      g_iSelect := 0;

    elsif g_iWidget = btnNo5 then
      if EntryMode = YNShippingAddress then
        EntryMode := ShippingMode;
        SelectScreen(g_ciShip);
      elsif EntryMode = YNClearOneMode then
        EntryMode := CustomerSelectMode;
        DisplayStatus("Loading Customers...");
        DisplayCustomersDB;     
        DisplayStatus("Selection NOT Cleared");  
      end if;
      g_iSelect := 0;      
    
    elsif g_iWidget = btnReset then
      g_iBatchAcc := 0;
      g_rSandAccum := 0;
      g_rCemAccum := 0;
      lastReset := Date$(SystemTime);
      setupScreen;

    elsif g_iWidget = lbprint then
      Print(GrossFmt);

    end if;

    EnableHandler(WidgetClicked); 
   
  end; 

begin

  setmenubarcolor("Black");
  Ready;       

end reverse; 