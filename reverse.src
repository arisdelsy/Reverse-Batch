program reverse;

#include reverse.iri 

--Screens
  g_ciMain    : constant integer := 14;
  g_ciCust    : constant integer := 2;
  g_ciProduct : constant integer := 4;
  g_ciYN      : constant integer := 5;
  g_ciSetup   : constant integer := 10;
  g_ciBatch   : constant integer := 1;
  g_ciaddcust : constant integer := 8;
  g_ciScales  : constant integer := 9;
  g_ciAddOns  : constant integer := 13;

  -- Global/Types variables definitions 
  g_sSetupPassword : stored string;
  g_iDownload : stored integer;
  g_sTmpPassword : string;  
  g_rCountby : real;    
  --g_ibUpdate : boolean;
  g_iDecimal1 : integer;  
  g_uUnits : Units; 
  g_sysResult : SysCode;   
  g_iDebug : integer;
  g_rScaleEmptyWeight : stored real;
  g_rScaleDischargeTime : stored real;
  g_iRecipeId : stored integer;  
  g_iTotalNbrIngredients : integer;    
  g_iCurrentIngredient : integer;    
  g_iDelayCnt : integer; 
  g_iWidget : integer; -- this is for widget alias 
  g_iWidgetNum : integer; -- this is for columns
  Select1   : integer;
  g_ciMaxPerScreen :integer;
  g_iWaitSSScale : integer;
  g_iUpdate : integer;
  g_iPage : integer;
  g_sysResult : SysCode;
  r1currrect_select : integer;   
  r2currrect_select : integer; 
  

  --Entry Modes are made to prevent deadlock 
  -- If you dont have them the program is vulnerable and could lock up
  NoMode              : constant integer := 0;
  CustomerSelectMode  : constant integer := 1000;
  RecipeSelectMode    : constant integer := 1001;
  SetupMenuMode       : constant integer := 1002;
  BatchMode           : constant integer := 1003;
  AutoPrintMode       : constant integer := 1004;
  ManualPrintMode     : constant integer := 1005;
  CustomerProcessMode : constant integer := 1006;
  ProductSelectMode   : constant integer := 1007;
  BatchCompleteMode   : constant integer := 1008;

-- Aris added new modes
-- Entry Modes for customer entry
  EnterOrderMode          : constant integer := 1009;
  EnterNameMode           : constant integer := 1010;
  EnterStreetMode         : constant integer := 1011;
  EnterTownMode           : constant integer := 1012;
  EnterStateMode          : constant integer := 1013;
  EnterZipCodeMode            : constant integer := 1014;
 
 
 -- Number of Max record
  g_ciMaxRecords            : constant integer := 1000;


  EntryMode : integer;
  g_Entrymode : integer;

  --Temp variables for entry for customer info
  t_order     : integer;
  t_customer  : string;
  t_street    : string;
  t_town      : string;
  t_state     : string;
  t_zip       : integer;
  Blank : constant string := "";

  --Temp variables for product information
  t_psi       : integer;
  t_qtyconc   : real;
  t_sand      : real;
  t_cement    : real;
  t_wat_gal   : real;
  t_calcium   : integer;
  t_air_ent   : real;
  t_antihydr  : real;
  t_retard    : real;

  type boolean is (False,True);
  r1_select : boolean;
  r2_select : boolean;

  type DisplayRecord is
    record 
      sOrderNum : string; 
      sName : string;
    end record;     

-- this means we are creating a new type called DisplayArrays is an array which holds g_ciMaxRecords
-- amount of information which is a part of the DisplayRecord type (declared above)
  type DisplayArrays is array [g_ciMaxRecords] of DisplayRecord; 
  g_arDisplay : DisplayArrays; 

  CustomersDB : CustomerDatabase;
  ProductDB   : ProductDatabase;
  
  procedure SetupStartTimer(iTimer : integer; iDuration : integer; itmMode : TimerMode); -- Setup a Timer and Start                                
  begin
  
    SetTimer(iTimer, iDuration);
    SetTimerMode(iTimer, itmMode);
    StartTimer(iTimer);
    
  end; 

  procedure WaitSS(iScale : integer);
  begin
    
    g_iWaitSSScale := iScale;
    SetupStartTimer(25, 10, TimerContinuous);
  
  end;   

  function CalcDecimal(rCountBy : real) : integer;  -- Calculates the amount of decimal positions  
    iDecimal : integer := 0;    
  begin   
         
    while rCountBy < 1.0
    loop    
      iDecimal := iDecimal + 1;
      rCountBy := rCountBy * 10.0;  
     end loop;

     return iDecimal; 
     
  end;

  procedure ClearDisplayListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxRecords 
    loop
      if g_arDisplay[i].sOrderNum = Blank then  
        return;
      end if;

      g_arDisplay[i].sOrderNum := Blank;
      g_arDisplay[i].sName := Blank; 

    end loop;
         
  end;

  procedure ClearWidgetsData;  -- Clear Display  List Screen text boxes
    i : integer;
  begin  
  
    for i := MinL2 to MaxL2 
    loop
      SetLabelText(i, Chr$(08)); -- 
    end loop;

  end; 

  procedure ClearCustomerTemp;
  begin

    t_order     := 0;
    t_customer  := Blank;
    t_street    := Blank;
    t_town      := Blank;
    t_state     := Blank;
    t_zip       := 0;

  end;
  
  procedure DisplayCustomersDB; 
    i : integer;
    j : integer;
  begin 

    -- Clear Text Boxes & Widgets
    ClearWidgetsData;
    
    -- Clear Array
    ClearDisplayListArray; 
    
    -- Sort DB or Get Based of Criteria                                       
    CustomersDB.Sort(1);                                    
    i := 1; 
    
    -- FillArray
    if CustomersDB.GetFirst = SysOk then  

      g_arDisplay[i].sOrderNum := IntegerToString(CustomersDB.Order,0);  -- for item 
      g_arDisplay[i].sName := CustomersDB.Name;  
      i := 2;            
 
      while CustomersDB.GetNext = SysOk  
      loop         
        if i <= g_ciMaxRecords then             
          g_arDisplay[i].sOrderNum := IntegerToString(CustomersDB.Order,0);  
      		g_arDisplay[i].sName := CustomersDB.Name;                                               
          i := i + 1;                          
        end if;       
      end loop; 
      
    end if; 
    
    -- Select Screen, Enable Handlers, Clear Screen and initialize variables
    SelectScreen(g_ciCust);                                       
    i := MinL2;  
    SetSymbolState(g_iWidgetNum, 1);
    g_iPage := 1;          
    j := 1;   
    
    -- Populate Screen
    while g_arDisplay[j].sOrderNum <> Blank and j <= g_ciMaxPerScreen   
    loop    
      SetLabelText(i, g_arDisplay[j].sOrderNum);
      SetLabelText(i + 1, g_arDisplay[j].sName);  
      i := i + 3;
      j := j + 1;   
    end loop;                            

  end;   

  procedure SelectProduct;
    i : integer;
  begin

    for i := minL4 to maxL4
    loop
      SetwidgetColor(i, "Black");
    end loop;

   --r1 = BTN 108-111
   --r2 = BTN 112-116
    if g_iwidget >= 108 and g_iwidget <= 111 then 
      if r1_select = true and r1currrect_select= g_iwidget then 
        r1_select = False;
      else 
        r1_select = True;
        r1currect_select := g_iwidget;
      end if;
    end if;

    if g_iwidget >= 112 and g_iwidget <= 116 then 
      if r2_select = true and r2currrect_select= g_iwidget then 
        r2_select = False;
      else 
        r2_select = True;
        r2currect_select := g_iwidget;
      end if;
    end if;

    if r1_select = true and r2_select = true then
      SetWidgetVisibility(btnNxt, Von);
    end if; 

  end;

  procedure LoadProduct;
  begin

    if r1currect_select = 108 and r2currect_select = 112 then
      t_psi := ProductDB.PSI;

  end;

  --For Aris hehe :)
  procedure SelectCustomer;
    iTouch : integer;
    i : integer;
  begin

    iTouch := g_iWidget mod 2; --there is two columns on the screen so we are dividing by 2  
    for i := minL2 to maxL2
    loop
      SetwidgetColor(i, "Black");
    end loop;
  -- if the number of the widget is divided by 2, the remainder will determine what button is turned 
    if iTouch = 0 then
      Setwidgetcolor(g_iWidget, "#BB0000");
      SetwidgetColor(g_iWidget + 1, "#BB0000");
      SetwidgetColor(g_iWidget - 1, "#BB0000");
    elsif iTouch = 1 then
      Setwidgetcolor(g_iWidget, "#BB0000");
      SetwidgetColor(g_iWidget - 1, "#BB0000");
      SetwidgetColor(g_iWidget - 2, "#BB0000");
    end if;
    Select1 := g_iWidget;

  end;


  procedure setupScreen; -- populate the setup screen 
  i : integer;
  begin

    -- setting background bars for screens
    for i := 1 to 16
    loop
      Setbargraphlevel(i,100); 
    end loop;
    --SetImageWidgetPath(btnSetup, "local://11.png");

  end;

  procedure PromptForEntry(sPrompt : string;  iMode : integer; sDefault : string; iPrompt : integer);  -- Prompts operator for data
  begin
    
    DisableHandler(NumericKeyPressed);
    DisableHandler(EnterKeyPressed);
    DisableHandler(NavUpKeyPressed);
    DisableHandler(NavDownKeyPressed);   
     
		SetEntry(sDefault);
    if iPrompt = 1 then   
      PromptUser(sPrompt);
    elsif iPrompt = 2 then
      PromptNumeric(sPrompt);
    elsif iPrompt = 3 then
      PromptPassword(sPrompt);
    else
      PromptUser(sPrompt);  
    end if;
    g_EntryMode := iMode;
    
  end;  

--new changes Aris 
handler UserEntry; -- Built in and 
  sTemp : string;
begin
  sTemp := GetEntry; -- is the action of getting user entry
  ClosePrompt;


  --Processcustomerentry? in each individual elif condition?

  --This is only going to show up for new customer entries
  if g_Entrymode = EnterOrderMode then 
    SetLabelText(lbl224, sTemp);
    t_order := sTemp; -- will this be used for printing, variable t_order?
    --CustomersDB := sTemp;
    
    -----------------------------------------------------
    --if CustomersDB.FindFirst(Customer_Order) = SysOk then
      --g_iUpdate := 1; 
    --elsif sTemp = Blank then
        --PromptForEntry("Invalid Order Number - Retry", EnterOrderMode, Blank, 1);
    -- THIS WAS AN ATTEMPT TO VERIFY IF STEMP IS BLANK  
    ------------------------
      
    --CustomersDB.Order := StringToInteger(sTemp);
    --if CustomersDB.FindFirst(Customer_Name) = Sysok then
      --g_iUpdate := 1; --boolean
      --SetEntry(CustomersDB.Name);
    --else
      --g_iUpdate := 0;
    --end if;
  elsif g_Entrymode = EnterNameMode then 
    SetLabelText(lbl225, sTemp);
    t_customer := sTemp;
    --CustomersDB.Name := sTemp;
    --if CustomersDB.FindFirst(Customer_Name) = Sysok then
      --g_iUpdate := 1;
      --SetEntry(CustomersDB.Name);
    --else
      --g_iUpdate := 0;
    --end if;
    --this is for blank
  elsif g_Entrymode = EnterStreetMode then 
    SetLabelText(lbl226, sTemp);
    t_street := sTemp;
    --CustomersDB.Street := sTemp;
    --if CustomersDB.FindFirst(Customer_Street) = Sysok then
      --g_iUpdate := 1;
      --SetEntry(CustomersDB.Street);
    --else
      --g_iUpdate := 0;
      --end if;
      --this is for blank
  elsif g_Entrymode = EnterTownMode then 
    SetLabelText(lbl227, sTemp);
    t_town := sTemp;
    --CustomersDB.Town := sTemp;
    --if CustomersDB.FindFirst(Customer_Town) = Sysok then
      --g_iUpdate := 1;
      --SetEntry(CustomersDB.Town);
    --else
      --g_iUpdate := 0;
      --end if;
  elsif g_Entrymode = EnterStateMode then 
    SetLabelText(lbl228, sTemp);
    t_state := sTemp;
    --CustomersDB.State := sTemp;
    --if CustomersDB.FindFirst(Customer_State) = Sysok then
      --g_iUpdate := 1;
      --SetEntry(CustomersDB.State);
    --else
      --g_iUpdate := 0;
    --end if;
  elsif g_Entrymode = EnterZipCodeMode then 
    SetLabelText(lbl229, sTemp);
    t_zip := sTemp;
    --CustomersDB.ZipCode := StringToInteger(sTemp);
    --if CustomersDB.FindFirst(Customer_ZipCode) = Sysok then
      --g_iUpdate := 1;
      --SetEntry(IntegerToString(CustomersDB.ZipCode,5));
    --else
      --g_iUpdate := 0;
    --end if;
  end if;  

end;


procedure ProcessingCustomerEntry(sTemp :string);
begin

  CustomersDB.Order := t_order;
  CustomersDB.Name := t_customer;
  CustomersDB.Street := t_street;
  CustomersDB.Town := t_town;
  CustomersDB.State := t_state;
  CustomersDB.Zip := t_zip;
  g_sysResult := CustomersDB.Add;

  if CustomersDB.FindFirst(Customer_Order) = Sysok then
    g_iUpdate := 1;
    --SetEntry(CustomersDB.Order); 
  else
    g_iUpdate := 0; 
  end if;
  CustomersDB.Name := t_customer;
  if CustomersDB.FindFirst(Customer_Name) = Sysok then
    g_iUpdate := 1;
  
--this should be appended
    --SetEntry(CustomersDB.Name);
  elsif 
    g_iUpdate := 0;
  end if;

  CustomersDB.Street := t_street;
  if CustomersDB.FindFirst(Customer_Street) = Sysok then
    g_iUpdate := 1; 
    --SetEntry(CustomersDB.Name);
  else
    g_iUpdate := 0;
  end if;

  CustomersDB.Town := t_town;
  if CustomersDB.FindFirst(Customer_Town) = Sysok then 
    g_iUpdate := 1;
  else 
    g_iUpdate := 0;
  end if;

  CustomersDB.State := t_state;
  if CustomersDB.FindFirst(Customer_State) = Sysok then 
    g_iUpdate := 1;

  else
    g_iUpdate := 0; 
  end if;
  CustomersDB.ZipCode := t_zip;
  if CustomersDB.FindFirst(Customer_ZipCode) = Sysok then
    g_iUpdate := 1;

  else 
    g_iUpdate := 0;
  end if;
end;
procedure RetrieveEntry;
begin 
  if CustomersDB.FindNext(Customer)

end;

procedure Ready;  -- Initialization procedure
begin

  --UnLockMajorKeys;
  setupScreen;
  --SetLabelText(lbSts1, Blank);     
  if GetUnits(1, g_uUnits) = SysOk then
    if GetCountBy(1, g_uUnits, g_rCountby) = SysOk then
      g_iDecimal1 := CalcDecimal(g_rCountby); 
    end if;
  end if;              
  --Paused := No;
  --BatchMode := Complete;  
  --RefreshMainDisplay;
  --SetWidgetVisibility(btnRPrnt, Voff);
  EntryMode := NoMode;
  SelectScreen(g_ciMain); 
  
end;

handler timer5Trip;
begin

  EntryMode := BatchCompleteMode;
  SelectScreen(g_ciBatch);

end;

handler WidgetClicked;
  begin

  	DisableHandler(WidgetClicked);
		g_iWidget := EventWidget;
		DisplayStatus("");

    if g_iWidget = btnStrt then
      if EntryMode = NoMode then
        EntryMode := CustomerSelectMode;
        SelectScreen(g_ciCust);
      end if;

    -- this allows for a range of widget numbers for a selection screen (for Customer Selection Screen)
    elsif g_iWidget >= MinL2 and g_iWidget <= MaxL2 then
      EntryMode := CustomerProcessMode;
      SelectScreen(g_ciaddcust);
      
      --SelectScreen(g_ciProduct);

    elsif g_iWidget = btnCont2 or g_iWidget = btnCont1 then
      if EntryMode = CustomerProcessMode then
        EntryMode := ProductSelectMode;
        if FileExists("/sdimages/next.png", SDCard) = SysOk then
          SetImageWidgetPath(btnNxt, "/next.png");
        else
          SetImageWidgetPath(btnNxt, "local://10.png");
        end if;
        --SetImageWidgetPath(btnNxt, "/sdimages/next.png");
        SelectScreen(g_ciProduct);
      end if;

    elsif g_iWidget = btnExt2 then
      if EntryMode = CustomerSelectMode then
        EntryMode := NoMode;
        SelectScreen(g_ciMain);
      end if;

    elsif g_iWidget = btnExt4 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
 
    elsif g_iWidget = btnPrint then  
      Print(GrossFmt);

    elsif g_iWidget = btnDone then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnExt12 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = btnExt10 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnSetup then
      EntryMode:= SetupMenuMode;
      setupScreen;
      SelectScreen(g_ciSetup);
-- new changes by aris
    elsif g_iWidget = btnNxt then
      EntryMode := BatchMode;
      SelectScreen(g_ciScales);
      SetupStartTimer(5, 500, TimerOneShot);
    
    elsif g_iWidget = btnExt13 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = lbl224 then
      PromptForEntry("Enter Order Number", EnterOrderMode, Blank,1);

    elsif g_iWidget = lbl225 then
      PromptForEntry("Enter Customer Name", EnterNameMode, Blank,1);
    
    elsif g_iWidget = lbl226 then
      PromptForEntry("Enter Street", EnterStreetMode, Blank,1);

    elsif g_iWidget = lbl227 then
      PromptForEntry("Enter Town", EnterTownMode, Blank,1);

    elsif g_iWidget = lbl228 then
      PromptForEntry("Enter State", EnterStateMode, Blank,1);

    elsif g_iWidget = lbl229 then
      PromptForEntry("Enter Zipcode", EnterZipCodeMode, Blank,2);

    elsif g_iWidget = btnCont1 or g_iWidget = btnCont2 then
      ProcessingCustomerEntry;
      ClearCustomerTemp;
      EntryMode := ProductSelectMode;

    end if;

    EnableHandler(WidgetClicked); 
   
  end;

procedure DisplayBatchComplete;
begin
  if g_EntryMode = BatchCompleteMode;
    SetLabelText(lblCust, t_customer);
    SetLabelText(lblShp1, t_street);
    SetLabelText(lblShp2, t_town);
    SetLabelText(lblShp3, t_state);
    --SetLabelText(lblProd, MISSING VARIABLE);  UNCOMMENT WHEN THIS SECTION IS DONE
    --SetLabelText(lbl275, MISSING TOTAL VARIABLE); UNCOMMENT WHEN THIS SECTION IS DONE
    end if;
end;



begin

  --DisableSetPoints; 
  --DisplayVersion; 
  setmenubarcolor("Black");
  Ready;       

end reverse; 