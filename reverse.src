program reverse;

#include reverse.iri 

--Screens
  g_ciMain    : constant integer := 14;
  g_ciCust    : constant integer := 2;
  g_ciProduct : constant integer := 4;
  g_ciYN      : constant integer := 5;
  g_ciSetup   : constant integer := 10;
  g_ciBatch   : constant integer := 1;
  g_ciaddcust : constant integer := 8;
  g_ciScales  : constant integer := 9;
  g_ciAddOns  : constant integer := 13;
  g_ciTest    : constant integer := 99;

  -- Global/Types variables definitions 
  g_sSetupPassword : stored string;
  g_iDownload : stored integer;
  g_sTmpPassword : string;  
  g_rCountby : real;    
  --g_ibUpdate : boolean;
  g_iDecimal1 : integer;  
  g_uUnits : Units; 
  g_sysResult : SysCode;   
  g_iDebug : integer;
  g_rScaleEmptyWeight : stored real;
  g_rScaleDischargeTime : stored real;
  g_iRecipeId : stored integer;  
  g_iTotalNbrIngredients : integer;    
  g_iCurrentIngredient : integer;    
  g_iDelayCnt : integer; 
  g_iWidget : integer; -- this is for widget alias 
  g_iWidgetNum : integer; -- this is for columns
  g_iSelect   : integer;
  g_ciMaxPerScreen :integer;
  g_iWaitSSScale : integer;
  g_iUpdate : integer;
  g_iPage : integer;
  r1current_select : integer;   
  r2current_select : integer; 
  g_iProductRow    : integer; -- mimics what is being done with g_iWidgetNum
  --Variables for storing inital weight of scales as well as target weights
  g_rInitial1 : real;
  g_rInitial2 : real;
  g_rtarget1  : real;
  g_rtarget2  : real;
  g_rActiveWeight1 : real;
  g_rActiveWeight2 : real;
  -- Printer port
  g_ciPrinter : constant integer := 1;

  --Entry Modes are made to prevent deadlock 
  -- If you dont have them the program is vulnerable and could lock up
  NoMode              : constant integer := 0;
  CustomerSelectMode  : constant integer := 1000;
  RecipeSelectMode    : constant integer := 1001;
  SetupMenuMode       : constant integer := 1002;
  BatchMode           : constant integer := 1003;
  AutoPrintMode       : constant integer := 1004;
  ManualPrintMode     : constant integer := 1005;
  CustomerProcessMode : constant integer := 1006;
  ProductSelectMode   : constant integer := 1007;
  BatchCompleteMode   : constant integer := 1008;
  AddOnsMode          : constant integer := 1015;

-- Entry Modes for customer entry
  EnterOrderMode          : constant integer := 1009;
  EnterNameMode           : constant integer := 1010;
  EnterStreetMode         : constant integer := 1011;
  EnterTownMode           : constant integer := 1012;
  EnterStateMode          : constant integer := 1013;
  EnterZipCodeMode            : constant integer := 1014;
 
 
 -- Number of Max record
  g_ciMaxRecords            : constant integer := 1000;
	g_ciMaxProducts						: constant integer := 20;	

  g_ciMaxPerSelectScreen    : constant integer := 8;

  Blank : constant string := "";

  EntryMode : integer;
  g_Entrymode : integer;

  --Temp variables for entry for customer info
  t_order     : string;
  t_customer  : string;
  t_street    : string;
  t_town      : string;
  t_state     : string;
  t_zip       : integer;
  

  --Temp variables for product information
  t_psi       : integer;
  t_qtyconc   : real;
  t_sand      : real;
  t_cement    : real;
  t_wat_gal   : real;
  t_calcium   : integer;
  t_air_ent   : real;
  t_antihydr  : real;
  t_retard    : real;

  type boolean is (False,True);
  r1_select : boolean := False;
  r2_select : boolean := False;

  bCalcium : boolean;
  bAnti_hydro : boolean;
  bAir_ent : boolean;
  bRetarder : boolean;

  type DisplayRecord is
    record 
      sOrderNum : string; 
      sName     : string;
      sStreet   : string;
      sTown     : string;
      sState    : string;
      iZip      : integer;
    end record;     

  type ProductRecord is
    record
      sPSI     : integer;
      sQTY_CONC: real;
      sSAND_MIX: real;
      sCEMENT  : real;
      sWAT_GALL: real;
      sCALCIUM : integer;
      sAIR_ENT : real;
      sANTIHYDR: real;
      sRETARDER: real;
    end record;    

-- this means we are creating a new type called DisplayArrays is an array which holds g_ciMaxRecords
-- amount of information which is a part of the DisplayRecord type (declared above)
  type DisplayArrays is array [g_ciMaxRecords] of DisplayRecord; 
  g_arDisplay : DisplayArrays;
  
  type ProductArrays is array [g_ciMaxProducts] of ProductRecord;
	g_arProduct : ProductArrays; --to make a selection from the product database

  CustomersDB : CustomerDatabase;
  ProductDB   : ProductDatabase;
  
  procedure SetupStartTimer(iTimer : integer; iDuration : integer; itmMode : TimerMode); -- Setup a Timer and Start                                
  begin
  
    SetTimer(iTimer, iDuration);
    SetTimerMode(iTimer, itmMode);
    StartTimer(iTimer);
    
  end; 

  procedure WaitSS(iScale : integer);
  begin
    
    g_iWaitSSScale := iScale;
    SetupStartTimer(25, 10, TimerContinuous);
  
  end;   

  function CalcDecimal(rCountBy : real) : integer;  -- Calculates the amount of decimal positions  
    iDecimal : integer := 0;    
  begin   
         
    while rCountBy < 1.0
    loop    
      iDecimal := iDecimal + 1;
      rCountBy := rCountBy * 10.0;  
     end loop;

     return iDecimal; 
     
  end;

  procedure PromptForEntry(sPrompt : string;  iMode : integer; sDefault : string; iPrompt : integer);  -- Prompts operator for data
  begin
    
    DisableHandler(NumericKeyPressed);
    DisableHandler(EnterKeyPressed);
    DisableHandler(NavUpKeyPressed);
    DisableHandler(NavDownKeyPressed);   
     
		SetEntry(sDefault);
    if iPrompt = 1 then   
      PromptUser(sPrompt);
    elsif iPrompt = 2 then
      PromptNumeric(sPrompt);
    elsif iPrompt = 3 then
      PromptPassword(sPrompt);
    else
      PromptUser(sPrompt);  
    end if;
    g_EntryMode := iMode;
    
  end;  

  procedure ProcessPromptCancel;   -- Performs Cancel operation when cancelling a prompt
    begin 
    
      ClosePrompt;  

      if Entrymode = EnterOrderMode then 
        EntryMode := CustomerProcessMode;
        t_order := Blank;
        SelectScreen(g_ciaddcust);
      elsif Entrymode = EnterNameMode then 
        EntryMode := CustomerProcessMode;
        t_customer := Blank;
        SelectScreen(g_ciaddcust);
      elsif Entrymode = EnterStreetMode then 
        EntryMode := CustomerProcessMode;
        t_street := Blank;
        SelectScreen(g_ciaddcust);
      elsif Entrymode = EnterTownMode then 
        EntryMode := CustomerProcessMode;
        t_town := Blank;
        SelectScreen(g_ciaddcust);
      elsif Entrymode = EnterStateMode then 
        EntryMode := CustomerProcessMode;
        t_state := Blank;
        SelectScreen(g_ciaddcust);
      elsif Entrymode = EnterZipCodeMode then 
        EntryMode := CustomerProcessMode;
        t_zip := 0;
        SelectScreen(g_ciaddcust);
      else   
        DisplayStatus(Blank); 
        EntryMode := NoMode;  
      end if;
      
    end;  

  procedure ProcessDataEntry(sTemp : string);
  begin
    --This is only going to show up for new customer entries
    if g_Entrymode = EnterOrderMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Order Number - Retry", EnterOrderMode, Blank, 1);
      end if;
      t_order := sTemp;
      SetLabelText(lbl224, t_order);
      EntryMode := CustomerProcessMode;
      --SetLabelText(lbl224, sTemp);
      --t_order := StringToInteger(sTemp); -- will this be used for printing, variable t_order?
        
    elsif g_Entrymode = EnterNameMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Customer Entry - Retry", EnterNameMode, Blank, 1);
      end if;
      SetLabelText(lbl225, sTemp);
      t_customer := sTemp;
      EntryMode := CustomerProcessMode;

    elsif g_Entrymode = EnterStreetMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Street Entry - Retry", EnterStreetMode, Blank, 1);
      end if;
      SetLabelText(lbl226, sTemp);
      t_street := sTemp;
      EntryMode := CustomerProcessMode;

    elsif g_Entrymode = EnterTownMode then
      if sTemp = Blank then
      
        PromptForEntry("Invalid Town Entry - Retry", EnterTownMode, Blank, 1);
      end if; 
      SetLabelText(lbl227, sTemp);
      t_town := sTemp;
      EntryMode := CustomerProcessMode;
    
    elsif g_Entrymode = EnterStateMode then 
      if sTemp = Blank then
      
        PromptForEntry("Invalid Order Number - Retry", EnterStateMode, Blank, 1);
      end if;
      SetLabelText(lbl228, sTemp);
      t_state := sTemp;
      EntryMode := CustomerProcessMode;
    
    elsif g_Entrymode = EnterZipCodeMode then
      if sTemp = Blank then
      
        PromptForEntry("Invalid Zip Code Number - Retry", EnterZipCodeMode, Blank, 1); 
      end if;
      SetLabelText(lbl229, sTemp);
      t_zip := StringToInteger(sTemp);
      EntryMode := CustomerProcessMode;
    
    end if;
  end;

   function GetSelection : integer;  -- Returns the current selected record in the display list    
    -- we choose function because it returns a value 
    i : integer;    
    begin
        if g_iSelect = 53 or g_iSelect = 54 then   
          g_iWidgetNum := 1;
        elsif g_iSelect = 55 or g_iSelect = 56 then
          g_iWidgetnum := 2;
        elsif g_iSelect = 57 or g_iSelect = 58 then
          g_iWidgetNum := 3;
        elsif g_iSelect = 59 or g_iSelect = 60 then
          g_iWidgetNum := 4;
        elsif g_iSelect = 61 or g_iSelect = 62 then
          g_iWidgetNum := 5;
        elsif g_iSelect = 63 or g_iSelect = 64 then
          g_iWidgetNum := 6;
        elsif g_iSelect = 65 or g_iSelect = 66 then
          g_iWidgetNum := 7;
        elsif g_iSelect = 67 or g_iSelect = 68 then
          g_iWidgetNum := 8;

        end if;

        i := (g_iPage - 1) * g_ciMaxPerSelectScreen + g_iWidgetNum;  
      
      return i;

    end;

  procedure ClearDisplayListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxRecords 
    loop
      if g_arDisplay[i].sOrderNum = Blank then  
        return;
      end if;

      g_arDisplay[i].sOrderNum := Blank;
      g_arDisplay[i].sName := Blank; 
      g_arDisplay[i].sStreet := Blank;
      g_arDisplay[i].sTown := Blank;
      g_arDisplay[i].sState := Blank;
      g_arDisplay[i].iZip := 0;

    end loop;
         
  end;

  procedure ClearProductListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxProducts  -- in the range from 1 to 1000
    loop

      g_arProduct[i].sPSI := 0;
      g_arProduct[i].sQTY_CONC := 0;  
      g_arProduct[i].sSAND_MIX := 0;
      g_arProduct[i].sCEMENT := 0;
      g_arProduct[i].sWAT_GALL := 0;
      g_arProduct[i].sCALCIUM := 0;
      g_arProduct[i].sAIR_ENT := 0;
      g_arProduct[i].sANTIHYDR := 0;
      g_arProduct[i].sRETARDER := 0; 

    end loop;
         
  end;

  --WHY IS THIS NOT BEING CALLED?
  procedure ClearWidgetsData;  -- Clear Display  List Screen text boxes
    i : integer;
  begin  
  
    for i := MinL2 to MaxL2 
    loop
      SetLabelText(i, Chr$(08)); -- 
    end loop;

  end; 

  procedure ClearCustomerTemp;
  begin

    t_order     := Blank;
    t_customer  := Blank;
    t_street    := Blank;
    t_town      := Blank;
    t_state     := Blank;
    t_zip       := 0;

  end;

  procedure ClearProductTemp;
  begin

    t_psi := 0;
    t_qtyconc := 0;
    t_sand := 0;
    t_cement := 0;
    t_wat_gal := 0;
    t_calcium := 0;
    t_air_ent := 0;
    t_antihydr := 0;
    t_retard := 0;

  end;
  
  procedure DisplayCustomersDB; 
    i : integer;
    j : integer;
  begin 
    
    --Makes all selections black
    for i := minL2 to maxL2
    loop
      SetwidgetColor(i, "Black");
    end loop;

    -- Clear Array
    ClearDisplayListArray; 
    
    -- Sort DB or Get Based of Criteria                                       
    CustomersDB.Sort(1);                                    
    i := 1; 
    
    -- FillArray
    if CustomersDB.GetFirst = SysOk then  

      g_arDisplay[i].sOrderNum := CustomersDB.Order;  -- for item 
      g_arDisplay[i].sName := CustomersDB.Name; 
      g_arDisplay[i].sStreet := CustomersDB.Street;
      g_arDisplay[i].sTown := CustomersDB.Town;
      g_arDisplay[i].sState := CustomersDB.State;
      g_arDisplay[i].iZip := CustomersDB.ZipCode;

      i := 2;            
 
      while CustomersDB.GetNext = SysOk  
      loop         
        if i <= g_ciMaxRecords then             
          g_arDisplay[i].sOrderNum := CustomersDB.Order;
          g_arDisplay[i].sName := CustomersDB.Name; 
          g_arDisplay[i].sStreet := CustomersDB.Street;
          g_arDisplay[i].sTown := CustomersDB.Town;
          g_arDisplay[i].sState := CustomersDB.State;
          g_arDisplay[i].iZip := CustomersDB.ZipCode;                     
          i := i + 1;                          
        end if;       
      end loop; 
    end if; 
    
    -- Select Screen, Enable Handlers, Clear Screen and initialize variables
    SelectScreen(g_ciCust);                                       
    i := MinL2;  
    SetSymbolState(g_iWidgetNum, 1);
    g_iPage := 1;          
    j := 1;   
    
    -- Populate Screen
    while g_arDisplay[j].sOrderNum <> Blank and j <= g_ciMaxPerSelectScreen   
    loop    
      SetLabelText(i, g_arDisplay[j].sOrderNum);
      SetLabelText(i + 1, g_arDisplay[j].sName);  
      i := i + 2;
      j := j + 1;   
    end loop;                            

    SetLabelText(Page2, "Page " + IntegerToString(g_iPage,0) + " out of 100");

  end;   

  procedure PageUporDownCustomerList(tmpPage : integer);  -- Page Up/Page Down the Display List 
    a : integer;
    i : integer;
    j : integer;
    b : integer;
  begin 
    
    -- Clear display
    for i := MinL2 to MaxL2
    loop
      SetLabelText(i, Blank);
    end loop;
    
    -- Find out where we are in the array
    if tmpPage = 1 then
      i := 1;                          -- g_ciMaxRecords MUST BE MULTIPLE OF 8
    elsif tmpPage >= 2 and tmpPage <= (g_ciMaxRecords/g_ciMaxPerSelectScreen) then
      i := (tmpPage * g_ciMaxPerSelectScreen) - 7;      
    else
      i := 1;
      g_iPage := 1;              
    end if;

    b := MinL2;
    j := i + 7; 
    
    -- Display the top of the list if we have reach the end 
    if g_arDisplay[i].sOrderNum = Blank then --and EntryMode <> CustomerSelectMode then
 
      DisplayCustomersDB;  

    else  
      
    -- Populate display with new data
    for a := i to j
    loop  
      if a > 0 and a <= g_ciMaxRecords then--and g_arDisplay[a].sOrderNum <> Blank then
        SetLabelText(b, g_arDisplay[a].sOrderNum);
        SetLabelText(b + 1, g_arDisplay[a].sName);  
        b := b + 2; 
      end if; 
    end loop;
       
    end if;
  
  SetLabelText(Page2, "Page " + IntegerToString(g_iPage,0) + " out of 100");

  end; 

  procedure ResetProduct;
  i : integer;
  begin
    for i := minL4 to maxL4
    loop
      SetwidgetColor(i, "Black");
    end loop;
  end;

  

  procedure FillProductArray;
  i : integer;
  begin
  
    ClearProductListArray;

    ProductDB.sort(1);
    i := 1;

    -- FillArray
    if ProductDB.GetFirst = SysOk then  -- .GetFirst gets the first logical record and it returns a syscode
      g_arProduct[i].sPSI := ProductDB.PSI;
      g_arProduct[i].sQTY_CONC := ProductDB.QTY_CONC;  
      g_arProduct[i].sSAND_MIX := ProductDB.SAND_MIX;
      g_arProduct[i].sCEMENT := ProductDB.CEMENT;
      g_arProduct[i].sWAT_GALL := ProductDB.WAT_GALL;
      g_arProduct[i].sCALCIUM := ProductDB.CALCIUM;
      g_arProduct[i].sAIR_ENT := ProductDB.AIR_ENT;
      g_arProduct[i].sANTIHYDR := ProductDB.ANTIHYDR;
      g_arProduct[i].sRETARDER := ProductDB.RETARDER; 
      i := 2;            
    end if; 
    while ProductDB.GetNext = SysOk  -- .GetNext gets the next record and it returns a syscode 
    loop         
      if i <= g_ciMaxRecords then             
        g_arProduct[i].sPSI := ProductDB.PSI;
        g_arProduct[i].sQTY_CONC := ProductDB.QTY_CONC;  
        g_arProduct[i].sSAND_MIX := ProductDB.SAND_MIX;
        g_arProduct[i].sCEMENT := ProductDB.CEMENT;
        g_arProduct[i].sWAT_GALL := ProductDB.WAT_GALL;
        g_arProduct[i].sCALCIUM := ProductDB.CALCIUM;
        g_arProduct[i].sAIR_ENT := ProductDB.AIR_ENT;
        g_arProduct[i].sANTIHYDR := ProductDB.ANTIHYDR;
        g_arProduct[i].sRETARDER := ProductDB.RETARDER;                                             
        i := i + 1;                          
      end if;       
    end loop; 
    
  end;

  procedure SelectProduct;
    i : integer;
  begin
  --r1 = BTN 108-111
  --r2 = BTN 112-116

    g_iProductRow := 0;

   --R1
    if g_iWidget >= 108 and g_iWidget <= 111 then 
      if r1_select = True and r1current_select = g_iWidget then 
        r1_select := False;
        SetWidgetColor(r1current_select, "Black");
        r1current_select := 0;
      elsif r1_select = True and r1current_select <> g_iWidget then
        SetWidgetColor(r1current_select, "Black");
        r1current_select := g_iWidget;
        SetWidgetColor(g_iWidget, "#BB0000");
      else 
        r1_select := True;
        SetWidgetColor(g_iWidget, "#BB0000");
        r1current_select := g_iWidget;
      end if;
    end if;


    --R2
    if g_iWidget >= 112 and g_iWidget <= 116 then 
      if r2_select = true and r2current_select = g_iWidget then 
        r2_select := False;
        SetWidgetColor(r2current_select, "Black");
        r2current_select := 0;
      elsif r2_select = True and r2current_select <> g_iWidget then
        SetWidgetColor(r2current_select, "Black");
        r2current_select := g_iWidget;
        SetWidgetColor(g_iWidget, "#BB0000");
      else 
        r2_select := True;
        SetWidgetColor(g_iWidget, "#BB0000");
        r2current_select := g_iWidget;
      end if;
    end if;

    if r1_select = true and r2_select = true then
      SetWidgetVisibility(btnNxt, Von);
    else
      SetWidgetVisibility(btnNxt, Voff);
    end if; 

  end;

  procedure GetProductSelection;
  begin
    if r1current_select = 108 and r2current_select = 112 then
      g_iProductRow := 1;
    elsif r1current_select = 108 and r2current_select = 113 then
      g_iProductRow := 2;
    elsif r1current_select = 108 and r2current_select = 114 then
      g_iProductRow := 3;
    elsif r1current_select = 108 and r2current_select = 115 then
      g_iProductRow := 4;
    elsif r1current_select = 108 and r2current_select = 116 then
      g_iProductRow := 5;
    elsif r1current_select = 109 and r2current_select = 112 then
      g_iProductRow := 6;
    elsif r1current_select = 109 and r2current_select = 113 then
      g_iProductRow := 7;
    elsif r1current_select = 109 and r2current_select = 114 then
      g_iProductRow := 8;
    elsif r1current_select = 109 and r2current_select = 115 then
      g_iProductRow := 9;
    elsif r1current_select = 109 and r2current_select = 116 then
      g_iProductRow := 10;
    elsif r1current_select = 110 and r2current_select = 112 then
      g_iProductRow := 11;
    elsif r1current_select = 110 and r2current_select = 113 then
      g_iProductRow := 12;
    elsif r1current_select = 110 and r2current_select = 114 then
      g_iProductRow := 13;
    elsif r1current_select = 110 and r2current_select = 115 then
      g_iProductRow := 14;
    elsif r1current_select = 110 and r2current_select = 116 then
      g_iProductRow := 15;
    elsif r1current_select = 111 and r2current_select = 112 then
      g_iProductRow := 16;
    elsif r1current_select = 111 and r2current_select = 113 then
      g_iProductRow := 17;
    elsif r1current_select = 111 and r2current_select = 114 then
      g_iProductRow := 18;
    elsif r1current_select = 111 and r2current_select = 115 then
      g_iProductRow := 19;
    elsif r1current_select = 111 and r2current_select = 116 then
      g_iProductRow := 20;
    else
      DisplayStatus("System Malfunction!");
      g_iProductRow := 0;
    end if;

  end;


  procedure LoadProduct;
  i : integer;
  begin
    
    --FOR TEST SCREEN
    --for i := testpsi to testanti
    --loop
      --SetLabelText(i, Chr$(08));
    --end loop;
    
    if g_iProductRow <> 0 then
      --FOR TEST SCREEN
      --SetLabelText(testpsi, g_arProduct[g_iProductRow].sPSI);
      --SetLabelText(testcon, g_arProduct[g_iProductRow].sQTY_CONC);
      --SetLabelText(testmix, g_arProduct[g_iProductRow].sSAND_MIX);
      --SetLabelText(testcem, g_arProduct[g_iProductRow].sCEMENT);
      --SetLabelText(testwat, g_arProduct[g_iProductRow].sWAT_GALL);
      --SetLabelText(testcal, g_arProduct[g_iProductRow].sCALCIUM);
      --SetLabelText(testair, g_arProduct[g_iProductRow].sAIR_ENT);
      --SetLabelText(testanti, g_arProduct[g_iProductRow].sANTIHYDR);
      --SetLabelText(testret, g_arProduct[g_iProductRow].sRETARDER);
      t_psi       := g_arProduct[g_iProductRow].sPSI;
      t_qtyconc   := g_arProduct[g_iProductRow].sQTY_CONC;
      t_sand      := g_arProduct[g_iProductRow].sSAND_MIX;
      t_cement    := g_arProduct[g_iProductRow].sCEMENT;
      t_wat_gal   := g_arProduct[g_iProductRow].sWAT_GALL;
      t_calcium   := g_arProduct[g_iProductRow].sCALCIUM;
      t_air_ent   := g_arProduct[g_iProductRow].sAIR_ENT;
      t_antihydr  := g_arProduct[g_iProductRow].sANTIHYDR;
      t_retard    := g_arProduct[g_iProductRow].sRETARDER;
          

    else
      DisplayStatus("ERROR! No Selection Made.");
    end if;

    r1current_select := 0;
    r2current_select := 0;
  end;

  procedure ProcessSelection;

  begin
    if g_iSelect <> 0 then
      if EntryMode = CustomerSelectMode then
        if g_arDisplay[GetSelection].sName <> Blank then   
          t_customer := g_arDisplay[GetSelection].sName;
          t_order    := g_arDisplay[GetSelection].sOrderNum;
          t_street   := g_arDisplay[GetSelection].sStreet;
          t_town     := g_arDisplay[GetSelection].sTown;
          t_state    := g_arDisplay[GetSelection].sState;
          t_zip      := g_arDisplay[GetSelection].iZip;
        else 
          DisplayStatus("Error: Please Enter A Customer");
          g_iSelect := 0;
        end if;
      end if;
    else
      Displaystatus("Select An Entry to Continue");
      EntryMode :=  CustomerSelectMode;
      g_iSelect := 0;    
    end if;

  end;


  procedure SelectCustomer;
    iTouch : integer;
    i : integer;
  begin

    iTouch := g_iWidget mod 2; --there is two columns on the screen so we are dividing by 2  
    for i := minL2 to maxL2
    loop
      SetwidgetColor(i, "Black");
    end loop;
  -- if the number of the widget is divided by 2, the remainder will determine what button is turned 
    if iTouch = 0 then
      Setwidgetcolor(g_iWidget, "#BB0000");
      SetwidgetColor(g_iWidget - 1, "#BB0000");
    elsif iTouch = 1 then
      Setwidgetcolor(g_iWidget, "#BB0000");
      SetwidgetColor(g_iWidget + 1, "#BB0000");
    end if;
    g_iSelect := g_iWidget;
    ProcessSelection;
  end;


  procedure setupScreen; -- populate the setup screen 
  i : integer;
  begin

    -- setting background bars for screens
    for i := 1 to 16
    loop
      Setbargraphlevel(i,100); 
    end loop;
    --SetImageWidgetPath(btnSetup, "local://11.png");

  end;

procedure ProcessingCustomerEntry;
begin
    CustomersDB.Order := t_order; -- we are temporarily setting the value of t_order to the database 
    CustomersDB.Name := t_customer;
    CustomersDB.Street := t_street;
    CustomersDB.Town := t_town;
    CustomersDB.State := t_state;
    CustomersDB.ZipCode := t_zip;

    g_sysResult := CustomersDB.FindFirst(Customer_Order); --This will equal SysOk if found in DB
    if g_sysResult <> SysOk then
      CustomersDB.Add;
    end if;
  
end;

procedure RunBatch;
begin

  --Batching concrete (using setpoints 1/2)
  --Calculation for target weight
  WaitSS(1);
  GetGross(1,Primary,g_rInitial1);

  g_rtarget1 := g_rInitial1 - t_cement;
  SetSPValue(1, g_rtarget1 + (g_rtarget1*0.25));
  SetSPValue(2, g_rtarget1);
  while()

  
  --Batching sand mix (using setpoints 3/4)
  WaitSS(2);
  GetGross(2,Primary,g_rInitial2);

  g_rtarget2 := g_rInitial2 - t_sand;

  


  --SetPoints

  SetSPValue(3, );
  SetSPValue(4, );


  DisplayStatus("HI");


end;

--new changes Aris 
	handler UserEntry; -- Built in and 
  	sTemp : string;
	begin
  	sTemp := GetEntry; -- is the action of getting user entry
  	ClosePrompt;
    
    if EventKey = EnterKey then
      ProcessDataEntry(sTemp);
    else
      ProcessPromptCancel;
    end if;
  --ProcessingCustomerEntry;
end;



procedure Ready;  -- Initialization procedure
begin

  --UnLockMajorKeys;
  setupScreen;
  --SetLabelText(lbSts1, Blank);     
  if GetUnits(1, g_uUnits) = SysOk then
    if GetCountBy(1, g_uUnits, g_rCountby) = SysOk then
      g_iDecimal1 := CalcDecimal(g_rCountby); 
    end if;
  end if;    
  r1_select := False;
  r2_select := False;
  

  --RefreshMainDisplay;
  --SetWidgetVisibility(btnRPrnt, Voff);
  EntryMode := NoMode;
  SelectScreen(g_ciMain); 
  
end;

procedure DefaultsForAddOns;
begin

  Setwidgetcolor(lbl127, "Black");
  Setwidgetcolor(lbl136, "Black");
  Setwidgetcolor(lbl132, "Black");
  Setwidgetcolor(lbl141, "Black");

  bCalcium := False;
  bAnti_hydro := False;
  bAir_ent := False;
  bRetarder := False;

  Setwidgetcolor(lbl128, "#BB0000");
  Setwidgetcolor(lbl137, "#BB0000");
  Setwidgetcolor(lbl133, "#BB0000");
  Setwidgetcolor(lbl142, "#BB0000");

end;

procedure TicketOutput;
  dTime : datetime := SystemTime;
begin
  DisplayStatus("Printing...");
  WriteLn(g_ciPrinter, "**************************" );

  WriteLn(g_ciPrinter, "Order #: " + t_order);
  WriteLn(g_ciPrinter, Space$(50) + UCase$(t_customer));
  WriteLn(g_ciPrinter, "Shipping Address:");
  WriteLn(g_ciPrinter, t_street);
  WriteLn(g_ciPrinter, t_town + "," + t_state);
  WriteLn(g_ciPrinter, "**************************" );
  WriteLn(g_ciPrinter, Blank);
  WriteLn(g_ciPrinter, Blank);

  WriteLn(g_ciPrinter, "Product Mix");
  WriteLn(g_ciPrinter, "PSI: " + IntegerToString(t_psi,0));
  WriteLn(g_ciPrinter, "Quantity of Concrete: " + RealToString(t_qtyconc, 6, 1) + "yds.");
  WriteLn(g_ciPrinter, "Sand & Stone Mix: " + RealToString(t_sand, 6, 1) + "lb.");
  WriteLn(g_ciPrinter, "Cement: " + RealToString(t_cement, 6, 1) + "lb.");
  WriteLn(g_ciPrinter, "Water: " + RealToString(t_wat_gal, 6, 1) + "gal.");

-- Aris: this will most likely be only if statements, 
-- that if the addon is yes then we display otherwise we
-- DO NOT print it on the ticket
  WriteLn(g_ciPrinter, "ADD ONS:");
  WriteLn(g_ciPrinter, "--------");

  if bCalcium = true  then
    WriteLn(g_ciPrinter, "Calcium? : YES ");
  end if;
  
  if bAnti_hydro = true then
    WriteLn(g_ciPrinter, "Anti Hydro? : YES ");
  end if;

  if bAir_ent = true then
    WriteLn(g_ciPrinter, "Air Entrainment? : YES ");
  end if;
  
  if bRetarder = true then
    WriteLn(g_ciPrinter, "Retarder? : YES ");
  end if;
  
end;

procedure DisplayBatchComplete;
begin
  if EntryMode = BatchCompleteMode then

    --dTime := SystemTime;
    SetLabelText(lblCust, t_customer);
    SetLabelText(lblShp1, t_street);
    SetLabelText(lblShp2, t_town);
    SetLabelText(lblShp3, t_state);
    SetLabelText(lblProd, RealToString(t_qtyconc,1,1) + " Yards " + IntegerToString(t_psi,0) + " PSI");
    SetLabelText(lbl275, RealToString(t_qtyconc,1,1) + " Yards");
  end if;
end;

handler WidgetClicked;
  begin

  	DisableHandler(WidgetClicked);
		g_iWidget := EventWidget;
		DisplayStatus("");

    if g_iWidget = btnStrt then
      EntryMode := CustomerSelectMode;
      DisplayCustomersDB;
      SelectScreen(g_ciCust);

    -- this allows for a range of widget numbers for a selection screen (for Customer Selection Screen)
    elsif g_iWidget >= MinL2 and g_iWidget <= MaxL2 then
      SelectCustomer;
      if FileExists("/sdimages/next.png", SDCard) = SysOk then
        SetImageWidgetPath(btnNxt, "/next.png");
      else
        SetImageWidgetPath(btnNxt, "local://10.png");
      end if;
      EntryMode := ProductSelectMode;
      SetWidgetVisibility(btnNxt, Voff);
      ResetProduct;
      FillProductArray;
      SelectScreen(g_ciProduct);

    elsif g_iWidget = btnCont2 or g_iWidget = btnCont1 then
      if t_order <> Blank then
        if EntryMode = CustomerProcessMode then
          ProcessingCustomerEntry;
          if g_sysResult <> SysOk then
            EntryMode := ProductSelectMode;
            if FileExists("/sdimages/next.png", SDCard) = SysOk then
              SetImageWidgetPath(btnNxt, "/next.png");
            else
              SetImageWidgetPath(btnNxt, "local://10.png");
            end if;
            --SetImageWidgetPath(btnNxt, "/sdimages/next.png");
            SetWidgetVisibility(btnNxt, Voff);
            ResetProduct;
            FillProductArray;
            SelectScreen(g_ciProduct);
          else
            DisplayStatus("ERROR! ENTRY ALREADY EXISTS! PLEASE USE A NEW ORDER NUMBER!");
          end if;
        end if;
      else
        DisplayStatus("ERROR: Please enter an order number!");
      end if;

    elsif g_iWidget >= 108 and g_iWidget <= 116 then
      -- !!! FOR TESTING PURPOSES !!! This will be a customer selection section
      SelectProduct;
      --SetupStartTimer(1,100,TimerOneShot);

    elsif g_iWidget = btnExt2 then
      if EntryMode = CustomerSelectMode then
        EntryMode := NoMode;
        SelectScreen(g_ciMain);
      end if;

    elsif g_iWidget = btnExt4 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
 
    elsif g_iWidget = btnPrint then  
      TicketOutput;
      --Print(GrossFmt); -- test purposes?
      -- EntryMode := ManualPrintMode;

    elsif g_iWidget = btnDone then
      ClearCustomerTemp;
      ClearProductTemp;
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnExt12 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = btnExt10 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnSetup then
      EntryMode:= SetupMenuMode;
      setupScreen;
      SelectScreen(g_ciSetup);

    elsif g_iWidget = btnNxt then
      if FileExists("/sdimages/next.png", SDCard) = SysOk then
        SetImageWidgetPath(btnNxt13, "/next.png");
      else
        SetImageWidgetPath(btnNxt13, "local://10.png");
      end if;
      GetProductSelection;
      LoadProduct; 
      EntryMode := AddOnsMode;
      SelectScreen(g_ciAddOns); 
      DefaultsForAddOns;
      
      -- (Note: we dont want to create lockup: which is like gridlock)
    
    elsif g_iWidget = btnNxt13 then
      --This stays here
      --EntryMode := BatchMode;
      --RunBatch;
      
      --TESTING BELOW
      EntryMode := BatchCompleteMode;
      DisplayBatchComplete;
      SelectScreen(g_ciBatch);

    elsif g_iWidget = btnExt13 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = lbl127 then
      if  bCalcium = False then
        SetWidgetColor(lbl128, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bCalcium := True;
      end if;
      
    elsif g_iWidget = lbl128 then 
      if bCalcium = True then 
        SetWidgetColor(lbl127, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bCalcium := False;
      end if;

    elsif g_iWidget = lbl132 then
      if  bAir_ent = False then
        SetWidgetColor(lbl133, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bAir_ent := True;
      end if;

    elsif g_iWidget = lbl133 then
      if  bAir_ent = True then
        SetWidgetColor(lbl132, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bAir_ent := False;
      end if;

    elsif g_iWidget = lbl136 then
      if  bAnti_hydro= False then
        SetWidgetColor(lbl137, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bAnti_hydro := True;
      end if;
    
    elsif g_iWidget = lbl137 then
      if  bAnti_hydro= True then
        bAnti_hydro := False;
        SetWidgetColor(lbl136, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
      end if;

    elsif g_iWidget = lbl141 then
      if  bRetarder = False then
        SetWidgetColor(lbl142, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bRetarder := True;
      end if;
    
    elsif g_iWidget = lbl142 then
      if  bRetarder = True then
        SetWidgetColor(lbl141, "Black");
        SetWidgetColor(g_iWidget, "#BB0000");
        bRetarder := False;
      end if;

    elsif g_iWidget = lbl224 then
      PromptForEntry("Enter Order Number", EnterOrderMode, Blank,1);

    elsif g_iWidget = lbl225 then
      PromptForEntry("Enter Customer Name", EnterNameMode, Blank,1);
    
    elsif g_iWidget = lbl226 then
      PromptForEntry("Enter Street", EnterStreetMode, Blank,1);

    elsif g_iWidget = lbl227 then
      PromptForEntry("Enter Town", EnterTownMode, Blank,1);

    elsif g_iWidget = lbl228 then
      PromptForEntry("Enter State", EnterStateMode, Blank,1);

    elsif g_iWidget = lbl229 then
      PromptForEntry("Enter Zipcode", EnterZipCodeMode, Blank,2);
    
    elsif g_iWidget = btnAdd then
      EntryMode := CustomerProcessMode;
      SelectScreen(g_ciaddcust);
    elsif g_iWidget = btnPgUp2 then
      g_iPage := g_iPage - 1;   
      SetSymbolState(g_iWidgetNum, 2);      
      PageUporDownCustomerList(g_iPage);  

    elsif g_iWidget = btnPgDn2 then
      g_iPage := g_iPage + 1;   
      SetSymbolState(g_iWidgetNum, 2);       
      PageUporDownCustomerList(g_iPage); 

    elsif g_iWidget = btnExt13 then
      EntryMode := NoMode;
      --DefaultsForAddOns;
      SelectScreen(g_ciMain);
    end if;

    EnableHandler(WidgetClicked); 
   
  end; 

begin

  --DisableSetPoints; 
  --DisplayVersion; 
  setmenubarcolor("Black");
  Ready;       

end reverse; 

--Used for printing values from batch selection
-- IntegerToString(g_arProduct[i].sPSI, 0);
-- RealToString(g_arProduct[i].sQTY_CONC, 6, 1);  
-- RealToString(g_arProduct[i].sSAND_MIX, 6, 1);
-- RealToString(g_arProduct[i].sCEMENT, 6, 1);
-- RealToString(g_arProduct[i].sWAT_GALL, 6, 1);
-- IntegerToString(g_arProduct[i].sCALCIUM, 0);
-- RealToString(g_arProduct[i].sAIR_ENT, 6, 1);
-- RealToString(g_arProduct[i].sANTIHYDR, 6, 1);
-- RealToString(g_arProduct[i].sRETARDER, 6, 1);


--setpoints are a value that are user defined, active if enabled or Disabled
--we only want is enabled if we are running a batch and disabled otherwise 

--the first setpoint will trigger the bar graph to turn yellow (100 pounds before the target is reached)
 

--target val + 75 
