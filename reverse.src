program reverse;

#include reverse.iri 

--Screens
  g_ciMain    : constant integer := 14;
  g_ciCust    : constant integer := 2;
  g_ciProduct : constant integer := 4;
  g_ciYN      : constant integer := 5;
  g_ciSetup   : constant integer := 10;
  g_ciBatch   : constant integer := 1;
  g_ciaddcust : constant integer := 8;
  g_ciScales  : constant integer := 9;
  g_ciAddOns  : constant integer := 13;
  g_ciTest    : constant integer := 99;

  -- Global/Types variables definitions 
  g_sSetupPassword : stored string;
  g_iDownload : stored integer;
  g_sTmpPassword : string;  
  g_rCountby : real;    
  --g_ibUpdate : boolean;
  g_iDecimal1 : integer;  
  g_uUnits : Units; 
  g_sysResult : SysCode;   
  g_iDebug : integer;
  g_rScaleEmptyWeight : stored real;
  g_rScaleDischargeTime : stored real;
  g_iRecipeId : stored integer;  
  g_iTotalNbrIngredients : integer;    
  g_iCurrentIngredient : integer;    
  g_iDelayCnt : integer; 
  g_iWidget : integer; -- this is for widget alias 
  g_iWidgetNum : integer; -- this is for columns
  Select1   : integer;
  g_ciMaxPerScreen :integer;
  g_iWaitSSScale : integer;
  g_iUpdate : integer;
  g_iPage : integer;
  r1current_select : integer;   
  r2current_select : integer; 
  

  --Entry Modes are made to prevent deadlock 
  -- If you dont have them the program is vulnerable and could lock up
  NoMode              : constant integer := 0;
  CustomerSelectMode  : constant integer := 1000;
  RecipeSelectMode    : constant integer := 1001;
  SetupMenuMode       : constant integer := 1002;
  BatchMode           : constant integer := 1003;
  AutoPrintMode       : constant integer := 1004;
  ManualPrintMode     : constant integer := 1005;
  CustomerProcessMode : constant integer := 1006;
  ProductSelectMode   : constant integer := 1007;
  BatchCompleteMode   : constant integer := 1008;

-- Aris added new modes
-- Entry Modes for customer entry
  EnterOrderMode          : constant integer := 1009;
  EnterNameMode           : constant integer := 1010;
  EnterStreetMode         : constant integer := 1011;
  EnterTownMode           : constant integer := 1012;
  EnterStateMode          : constant integer := 1013;
  EnterZipCodeMode            : constant integer := 1014;
 
 
 -- Number of Max record
  g_ciMaxRecords            : constant integer := 1000;
	g_ciMaxProducts						: constant integer := 20;	


  EntryMode : integer;
  g_Entrymode : integer;

  --Temp variables for entry for customer info
  t_order     : integer;
  t_customer  : string;
  t_street    : string;
  t_town      : string;
  t_state     : string;
  t_zip       : integer;
  Blank : constant string := "";

  --Temp variables for product information
  t_psi       : integer;
  t_qtyconc   : real;
  t_sand      : real;
  t_cement    : real;
  t_wat_gal   : real;
  t_calcium   : integer;
  t_air_ent   : real;
  t_antihydr  : real;
  t_retard    : real;

  type boolean is (False,True);
  r1_select : boolean := False;
  r2_select : boolean := False;

  type DisplayRecord is
    record 
      sOrderNum : string; 
      sName : string;
    end record;     

  type ProductRecord is
    record
      sPSI     : string;
      sQTY_CONC: string;
      sSAND_MIX: string;
      sCEMENT  : string;
      sWAT_GALL: string;
      sCALCIUM : string;
      sAIR_ENT : string;
      sANTIHYDR: string;
      sRETARDER: string;
    end record;    

-- this means we are creating a new type called DisplayArrays is an array which holds g_ciMaxRecords
-- amount of information which is a part of the DisplayRecord type (declared above)
  type DisplayArrays is array [g_ciMaxRecords] of DisplayRecord; 
  g_arDisplay : DisplayArrays;
  
  type ProductArrays is array [g_ciMaxProducts] of ProductRecord;
	g_arProduct : ProductArrays; --to make a selection from the product database

  CustomersDB : CustomerDatabase;
  ProductDB   : ProductDatabase;
  
  procedure SetupStartTimer(iTimer : integer; iDuration : integer; itmMode : TimerMode); -- Setup a Timer and Start                                
  begin
  
    SetTimer(iTimer, iDuration);
    SetTimerMode(iTimer, itmMode);
    StartTimer(iTimer);
    
  end; 

  procedure WaitSS(iScale : integer);
  begin
    
    g_iWaitSSScale := iScale;
    SetupStartTimer(25, 10, TimerContinuous);
  
  end;   

  function CalcDecimal(rCountBy : real) : integer;  -- Calculates the amount of decimal positions  
    iDecimal : integer := 0;    
  begin   
         
    while rCountBy < 1.0
    loop    
      iDecimal := iDecimal + 1;
      rCountBy := rCountBy * 10.0;  
     end loop;

     return iDecimal; 
     
  end;

  procedure ClearDisplayListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxRecords 
    loop
      if g_arDisplay[i].sOrderNum = Blank then  
        return;
      end if;

      g_arDisplay[i].sOrderNum := Blank;
      g_arDisplay[i].sName := Blank; 

    end loop;
         
  end;

  procedure ClearProductListArray;  -- Clear Display List Array
    i : integer;
  begin 
  
    for i := 1 to g_ciMaxProducts  -- in the range from 1 to 1000
    loop

      g_arProduct[i].sPSI := Blank;
      g_arProduct[i].sQTY_CONC := Blank;  
      g_arProduct[i].sSAND_MIX := Blank;
      g_arProduct[i].sCEMENT := Blank;
      g_arProduct[i].sWAT_GALL := Blank;
      g_arProduct[i].sCALCIUM := Blank;
      g_arProduct[i].sAIR_ENT := Blank;
      g_arProduct[i].sANTIHYDR := Blank;
      g_arProduct[i].sRETARDER := Blank; 

    end loop;
         
  end;

  procedure ClearWidgetsData;  -- Clear Display  List Screen text boxes
    i : integer;
  begin  
  
    for i := MinL2 to MaxL2 
    loop
      SetLabelText(i, Chr$(08)); -- 
    end loop;

  end; 

  procedure ClearCustomerTemp;
  begin

    t_order     := 0;
    t_customer  := Blank;
    t_street    := Blank;
    t_town      := Blank;
    t_state     := Blank;
    t_zip       := 0;

  end;
  
  procedure DisplayCustomersDB; 
    i : integer;
    j : integer;
  begin 

    -- Clear Text Boxes & Widgets
    ClearWidgetsData;
    
    -- Clear Array
    ClearDisplayListArray; 
    
    -- Sort DB or Get Based of Criteria                                       
    CustomersDB.Sort(1);                                    
    i := 1; 
    
    -- FillArray
    if CustomersDB.GetFirst = SysOk then  

      g_arDisplay[i].sOrderNum := IntegerToString(CustomersDB.Order,0);  -- for item 
      g_arDisplay[i].sName := CustomersDB.Name;  
      i := 2;            
 
      while CustomersDB.GetNext = SysOk  
      loop         
        if i <= g_ciMaxRecords then             
          g_arDisplay[i].sOrderNum := IntegerToString(CustomersDB.Order,0);  
      		g_arDisplay[i].sName := CustomersDB.Name;                                               
          i := i + 1;                          
        end if;       
      end loop; 
      
    end if; 
    
    -- Select Screen, Enable Handlers, Clear Screen and initialize variables
    SelectScreen(g_ciCust);                                       
    i := MinL2;  
    SetSymbolState(g_iWidgetNum, 1);
    g_iPage := 1;          
    j := 1;   
    
    -- Populate Screen
    while g_arDisplay[j].sOrderNum <> Blank and j <= g_ciMaxPerScreen   
    loop    
      SetLabelText(i, g_arDisplay[j].sOrderNum);
      SetLabelText(i + 1, g_arDisplay[j].sName);  
      i := i + 3;
      j := j + 1;   
    end loop;                            

  end;   

  procedure PageUporDownCustomerList(tmpPage : integer);  -- Page Up/Page Down the Display List 
    a : integer;
    i : integer;
    j : integer;
    b : integer;
  begin 
    
    -- Clear display
    for i := minLabel to maxLabel
    loop
      SetLabelText(i, Blank);
    end loop;
    
    -- Find out where we are in the array
    if tmpPage = 1 then
      i := 1;                          -- g_ciMaxRecords MUST BE MULTIPLE OF 8
    elsif tmpPage >= 2 and tmpPage <= (g_ciMaxRecords/g_ciMaxPerScreen) then
      i := (tmpPage * g_ciMaxPerScreen) - 7;      
    else
      i := 1;
      g_iPage := 1;              
    end if;

    b := minLabel;
    j := i + 7; 
    
    -- Display the top of the list if we have reach the end 
    if g_arDisplay[i].sID = Blank then -- and EntryMode <> SetupSelectTruck then
 
      DisplayInboundDB;  

    else  
      
      -- Populate display with new data
      for a := i to j
      loop  
        if a > 0 and a <= g_ciMaxRecords and g_arDisplay[a].sID <> Blank then
          SetLabelText(b, g_arDisplay[a].sID);
          SetLabelText(b + 1, g_arDisplay[a].sName);  
					SetLabelText(b + 2, g_arDisplay[a].sInDT);
          b := b + 3; 
        end if; 
      end loop;
       
    end if;

  end; 

  procedure SelectProduct;
    i : integer;
  begin

    for i := minL4 to maxL4
    loop
      SetwidgetColor(i, "Black");
    end loop;

   --r1 = BTN 108-111
   --r2 = BTN 112-116
    if g_iWidget >= 108 and g_iWidget <= 111 then 
      if r1_select = True and r1current_select = g_iWidget then 
        r1_select := False;
      else 
        r1_select := True;
        SetWidgetColor(g_iWidget, "#BB0000");
        r1current_select := g_iWidget;
      end if;
    end if;

    if g_iWidget >= 112 and g_iWidget <= 116 then 
      if r2_select = true and r2current_select= g_iWidget then 
        r2_select := False;
      else 
        r2_select := True;
        SetWidgetColor(g_iWidget, "#BB0000");
        r2current_select := g_iWidget;
      end if;
    end if;

    if r1_select = true and r2_select = true then
      SetWidgetVisibility(btnNxt, Von);
    else
      SetWidgetVisibility(btnNxt, Voff);
    end if; 

  end;

  procedure LoadProduct;
  i : integer;
  begin
  
    ClearProductListArray;


    i := 1;
    -- FillArray
    if ProductDB.GetFirst = SysOk then  -- .GetFirst gets the first logical record and it returns a syscode
      g_arProduct[i].sPSI := IntegerToString(ProductDB.PSI, 0);
      g_arProduct[i].sQTY_CONC := RealToString(ProductDB.QTY_CONC, 6, g_iDecimal1);  
      g_arProduct[i].sSAND_MIX := RealToString(ProductDB.SAND_MIX, 6, g_iDecimal1);
      g_arProduct[i].sCEMENT := RealToString(ProductDB.CEMENT, 6, g_iDecimal1);
      g_arProduct[i].sWAT_GALL := RealToString(ProductDB.WAT_GALL, 6, g_iDecimal1);
      g_arProduct[i].sCALCIUM := IntegerToString(ProductDB.CALCIUM, 0);
      g_arProduct[i].sAIR_ENT := RealToString(ProductDB.AIR_ENT, 6, g_iDecimal1);
      g_arProduct[i].sANTIHYDR := RealToString(ProductDB.ANTIHYDR, 6, g_iDecimal1);
      g_arProduct[i].sRETARDER := RealToString(ProductDB.RETARDER, 6, g_iDecimal1); 
      i := 2;            
    end if; 
    while CustomersDB.GetNext = SysOk  -- .GetNext gets the next record and it returns a syscode 
    loop         
      if i <= g_ciMaxRecords then             
        g_arProduct[i].sPSI := IntegerToString(ProductDB.PSI, 0);
        g_arProduct[i].sQTY_CONC := RealToString(ProductDB.QTY_CONC, 6, g_iDecimal1);  
        g_arProduct[i].sSAND_MIX := RealToString(ProductDB.SAND_MIX, 6, g_iDecimal1);
        g_arProduct[i].sCEMENT := RealToString(ProductDB.CEMENT, 6, g_iDecimal1);
        g_arProduct[i].sWAT_GALL := RealToString(ProductDB.WAT_GALL, 6, g_iDecimal1);
        g_arProduct[i].sCALCIUM := IntegerToString(ProductDB.CALCIUM, 0);
        g_arProduct[i].sAIR_ENT := RealToString(ProductDB.AIR_ENT, 6, g_iDecimal1);
        g_arProduct[i].sANTIHYDR := RealToString(ProductDB.ANTIHYDR, 6, g_iDecimal1);
        g_arProduct[i].sRETARDER := RealToString(ProductDB.RETARDER, 6, g_iDecimal1);                                             
        i := i + 1;                          
      end if;       
    end loop; 
    



    if r1current_select = 108 and r2current_select = 112 then
      t_psi := StringToInteger(g_arProduct[1].sPSI);
      t_qtyconc := StringToReal(g_arProduct[1].sQTY_CONC);
      t_sand := StringToReal(g_arProduct[1].sSAND_MIX);
      t_cement := StringToReal(g_arProduct[1].sCEMENT);
      t_wat_gal := StringToReal(g_arProduct[1].sWAT_GALL);
      t_calcium := StringToInteger(g_arProduct[1].sCALCIUM);
      t_air_ent := StringToReal(g_arProduct[1].sAIR_ENT);
      t_antihydr := StringToReal(g_arProduct[1].sANTIHYDR);
      t_retard := StringToReal(g_arProduct[1].sRETARDER);
    end if;
  end;

  --For Aris hehe :)
  procedure SelectCustomer;
    iTouch : integer;
    i : integer;
  begin

    iTouch := g_iWidget mod 2; --there is two columns on the screen so we are dividing by 2  
    for i := minL2 to maxL2
    loop
      SetwidgetColor(i, "Black");
    end loop;
  -- if the number of the widget is divided by 2, the remainder will determine what button is turned 
    if iTouch = 0 then
      Setwidgetcolor(g_iWidget, "#BB0000");
      SetwidgetColor(g_iWidget + 1, "#BB0000");
      SetwidgetColor(g_iWidget - 1, "#BB0000");
    elsif iTouch = 1 then
      Setwidgetcolor(g_iWidget, "#BB0000");
      SetwidgetColor(g_iWidget - 1, "#BB0000");
      SetwidgetColor(g_iWidget - 2, "#BB0000");
    end if;
    Select1 := g_iWidget;

  end;


  procedure setupScreen; -- populate the setup screen 
  i : integer;
  begin

    -- setting background bars for screens
    for i := 1 to 16
    loop
      Setbargraphlevel(i,100); 
    end loop;
    --SetImageWidgetPath(btnSetup, "local://11.png");

  end;

  procedure PromptForEntry(sPrompt : string;  iMode : integer; sDefault : string; iPrompt : integer);  -- Prompts operator for data
  begin
    
    DisableHandler(NumericKeyPressed);
    DisableHandler(EnterKeyPressed);
    DisableHandler(NavUpKeyPressed);
    DisableHandler(NavDownKeyPressed);   
     
		SetEntry(sDefault);
    if iPrompt = 1 then   
      PromptUser(sPrompt);
    elsif iPrompt = 2 then
      PromptNumeric(sPrompt);
    elsif iPrompt = 3 then
      PromptPassword(sPrompt);
    else
      PromptUser(sPrompt);  
    end if;
    g_EntryMode := iMode;
    
  end;  

--new changes Aris 
	handler UserEntry; -- Built in and 
  	sTemp : string;
	begin
  	sTemp := GetEntry; -- is the action of getting user entry
  	ClosePrompt;

  	--This is only going to show up for new customer entries
  	if g_Entrymode = EnterOrderMode then 
    	if sTemp = Blank then
        PromptForEntry("Invalid Order Number - Retry", EnterOrderMode, Blank, 1);
      end if;
      t_order := sTemp;
      SetLabelText(lbl224, t_order);
      --SetLabelText(lbl224, sTemp);
    	--t_order := StringToInteger(sTemp); -- will this be used for printing, variable t_order?
      	
  	elsif g_Entrymode = EnterNameMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid Customer Entry - Retry", EnterNameMode, Blank, 1);
      end if;
    	SetLabelText(lbl225, sTemp);
    	t_customer := sTemp;

  	elsif g_Entrymode = EnterStreetMode then 
      if sTemp = Blank then
    	
        PromptForEntry("Invalid Street Entry - Retry", EnterStreetMode, Blank, 1);
      end if;
      SetLabelText(lbl226, sTemp);
    	t_street := sTemp;
 
  	elsif g_Entrymode = EnterTownMode then
      if sTemp = Blank then
    	
        PromptForEntry("Invalid Town Entry - Retry", EnterTownMode, Blank, 1);
      end if; 
    	SetLabelText(lbl227, sTemp);
    	t_town := sTemp;
    
  	elsif g_Entrymode = EnterStateMode then 
      if sTemp = Blank then
    	
        PromptForEntry("Invalid Order Number - Retry", EnterStateMode, Blank, 1);
      end if;
    	SetLabelText(lbl228, sTemp);
    	t_state := sTemp;
    
  	elsif g_Entrymode = EnterZipCodeMode then
      if sTemp = Blank then
    	
        PromptForEntry("Invalid Zip Code Number - Retry", EnterZipCodeMode, Blank, 1); 
      end if;
    	SetLabelText(lbl229, sTemp);
    	t_zip := StringToInteger(sTemp);
    
  	end if;

  --ProcessingCustomerEntry;
end;

procedure ProcessingCustomerEntry(sTemp :string);
begin

  CustomersDB.Order := t_order; -- we are temporarily setting the value of t_order to the database 
  CustomersDB.Name := t_customer;
  CustomersDB.Street := t_street;
  CustomersDB.Town := t_town;
  CustomersDB.State := t_state;
  CustomersDB.Zip := t_zip;

  g_sysResult := CustomersDB.FindFirst(Customer_Order)
  
  CustomersDB.Add;
  if t_customer <> Blank then
    if t_order <> 0 and g_sysResult <> Sysok then 
      Customer_Order := t_order; 
    else  
      if t_order = 0 then 
        Customer_Order := t_order; 
      else
        DisplayStatus("Invalid number: Already in Database");
      end if;
    end if;
  else  
    SelectScreen(g_ciaddcust)
    DisplayStatus("Please put a Customer Name");
    --PromptForEntry("Enter Customer Name", EnterNameMode, Blank,1);


  end;

  
end;

procedure Ready;  -- Initialization procedure
begin

  --UnLockMajorKeys;
  setupScreen;
  --SetLabelText(lbSts1, Blank);     
  if GetUnits(1, g_uUnits) = SysOk then
    if GetCountBy(1, g_uUnits, g_rCountby) = SysOk then
      g_iDecimal1 := CalcDecimal(g_rCountby); 
    end if;
  end if;    
  r1_select := False;
  r2_select := False;          
  --Paused := No;
  --BatchMode := Complete;  
  --RefreshMainDisplay;
  --SetWidgetVisibility(btnRPrnt, Voff);
  EntryMode := NoMode;
  SelectScreen(g_ciMain); 
  
end;

handler timer5Trip;
begin

  EntryMode := BatchCompleteMode;
  SelectScreen(g_ciBatch);

end;

handler WidgetClicked;
  begin

  	DisableHandler(WidgetClicked);
		g_iWidget := EventWidget;
		DisplayStatus("");

    if g_iWidget = btnStrt then
      if EntryMode = NoMode then
        EntryMode := CustomerSelectMode;
        SelectScreen(g_ciCust);
      end if;

    -- this allows for a range of widget numbers for a selection screen (for Customer Selection Screen)
    elsif g_iWidget >= MinL2 and g_iWidget <= MaxL2 then
      --Commented out for testing ingredients without adding to database
      --EntryMode := CustomerProcessMode;
      --SelectScreen(g_ciaddcust);
      
      EntryMode := ProductSelectMode;
      SetWidgetVisibility(btnNxt, Voff);
      SelectScreen(g_ciProduct);

    elsif g_iWidget = btnCont2 or g_iWidget = btnCont1 then
      if EntryMode = CustomerProcessMode then
        EntryMode := ProductSelectMode;
        if FileExists("/sdimages/next.png", SDCard) = SysOk then
          SetImageWidgetPath(btnNxt, "/next.png");
        else
          SetImageWidgetPath(btnNxt, "local://10.png");
        end if;
        --SetImageWidgetPath(btnNxt, "/sdimages/next.png");
        SelectScreen(g_ciProduct);
      end if;

    elsif g_iWidget >= 108 and g_iWidget <= 116 then
      -- !!! FOR TESTING PURPOSES !!! This will be a customer selection section
      SelectProduct;
      SelectScreen(g_ciTest);
      SetupStartTimer(1,100,TimerOneShot);

    elsif g_iWidget = btnExt2 then
      if EntryMode = CustomerSelectMode then
        EntryMode := NoMode;
        SelectScreen(g_ciMain);
      end if;

    elsif g_iWidget = btnExt4 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
 
    elsif g_iWidget = btnPrint then  
      Print(GrossFmt);

    elsif g_iWidget = btnDone then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnExt12 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = btnExt10 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);
    
    elsif g_iWidget = btnSetup then
      EntryMode:= SetupMenuMode;
      setupScreen;
      SelectScreen(g_ciSetup);
-- new changes by aris
    elsif g_iWidget = btnNxt then
      --EntryMode := BatchMode;
      --SelectScreen(g_ciScales);
      --SetupStartTimer(5, 500, TimerOneShot);

      EntryMode := NoMode;
      --Select test screen
    
    elsif g_iWidget = btnExt13 then
      EntryMode := NoMode;
      SelectScreen(g_ciMain);

    elsif g_iWidget = lbl224 then
      PromptForEntry("Enter Order Number", EnterOrderMode, Blank,1);

    elsif g_iWidget = lbl225 then
      PromptForEntry("Enter Customer Name", EnterNameMode, Blank,1);
    
    elsif g_iWidget = lbl226 then
      PromptForEntry("Enter Street", EnterStreetMode, Blank,1);

    elsif g_iWidget = lbl227 then
      PromptForEntry("Enter Town", EnterTownMode, Blank,1);

    elsif g_iWidget = lbl228 then
      PromptForEntry("Enter State", EnterStateMode, Blank,1);

    elsif g_iWidget = lbl229 then
      PromptForEntry("Enter Zipcode", EnterZipCodeMode, Blank,2);

    end if;

    EnableHandler(WidgetClicked); 
   
  end;

procedure DisplayBatchComplete;
begin
  if g_EntryMode = BatchCompleteMode;
    SetLabelText(lblCust, t_customer);
    SetLabelText(lblShp1, t_street);
    SetLabelText(lblShp2, t_town);
    SetLabelText(lblShp3, t_state);
    --SetLabelText(lblProd, MISSING VARIABLE);  UNCOMMENT WHEN THIS SECTION IS DONE
    --SetLabelText(lbl275, MISSING TOTAL VARIABLE); UNCOMMENT WHEN THIS SECTION IS DONE
    end if;
end;



begin

  --DisableSetPoints; 
  --DisplayVersion; 
  setmenubarcolor("Black");
  Ready;       

end reverse; 